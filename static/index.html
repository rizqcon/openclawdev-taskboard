<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEV Task Board</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* Dark mode scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a;
        }
        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: #334155 #0f172a;
        }
        
        :root {
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-column: #1a2332;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --accent: #00b4d8;
            --accent-hover: #38bdf8;
            --critical: #ef4444;
            --high: #f97316;
            --medium: #eab308;
            --low: #22c55e;
            --border: #334155;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            background: var(--bg-card);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            position: relative;
            z-index: 100;
        }
        
        .header.command-active {
            z-index: 350;
        }
        
        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .header h1 span { color: var(--accent); }
        
        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        /* Command Bar - Jarvis Chat */
        .command-bar {
            flex: 1;
            max-width: 600px;
            margin: 0 1.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            position: relative;
        }
        
        .command-bar:hover {
            border-color: var(--accent);
        }
        
        .command-bar.expanded {
            cursor: default;
            border-color: var(--accent);
            z-index: 301;
            position: relative;
        }
        
        .command-bar-collapsed {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
        }
        
        .command-bar-icon {
            font-size: 1.25rem;
        }
        
        .command-bar-preview {
            color: var(--text-muted);
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .command-bar-expanded {
            display: none;
            flex-direction: column;
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 720px;
            background: var(--bg-card);
            border: 2px solid var(--accent);
            border-radius: 12px;
            box-shadow: 0 12px 60px rgba(0, 0, 0, 0.9), 0 0 30px rgba(0, 180, 216, 0.3);
            z-index: 300;
            pointer-events: auto;
        }
        
        .command-bar.expanded .command-bar-expanded {
            display: flex;
        }
        
        .command-bar-expanded.fullsize {
            width: 95vw;
            max-width: 95vw;
            top: 50%;
            transform: translate(-50%, -50%);
            height: 95vh;
            max-height: 95vh;
        }
        
        .command-bar-expanded.fullsize .jarvis-chat-container {
            height: calc(95vh - 60px);
        }
        
        /* Native Jarvis Chat Styles */
        .jarvis-chat-container {
            display: flex;
            flex-direction: column;
            height: 500px;
            background: var(--bg-card);
            border-radius: 0 0 12px 12px;
        }
        
        .jarvis-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .jarvis-message {
            padding: 0.75rem 1rem;
            border-radius: 12px;
            max-width: 85%;
            font-size: 0.9rem;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .jarvis-message.user {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            align-self: flex-end;
            margin-left: 15%;
        }
        
        .jarvis-message.assistant {
            background: rgba(99, 102, 241, 0.15);
            border: 1px solid rgba(99, 102, 241, 0.3);
            align-self: flex-start;
            margin-right: 15%;
        }
        
        .jarvis-message .msg-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }
        
        .jarvis-message .msg-content {
            line-height: 1.6;
        }
        
        /* Markdown styling for command bar chat */
        .jarvis-message .msg-content p {
            margin: 0 0 0.5rem 0;
        }
        .jarvis-message .msg-content p:last-child {
            margin-bottom: 0;
        }
        .jarvis-message .msg-content ul,
        .jarvis-message .msg-content ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .jarvis-message .msg-content li {
            margin: 0.25rem 0;
        }
        .jarvis-message .msg-content code {
            background: var(--bg-dark);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        .jarvis-message .msg-content pre {
            background: var(--bg-dark);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
        }
        .jarvis-message .msg-content pre code {
            background: none;
            padding: 0;
        }
        .jarvis-message .msg-content blockquote {
            border-left: 3px solid var(--accent);
            margin: 0.5rem 0;
            padding-left: 1rem;
            color: var(--text-muted);
        }
        .jarvis-message .msg-content h1,
        .jarvis-message .msg-content h2,
        .jarvis-message .msg-content h3 {
            margin: 0.75rem 0 0.5rem 0;
            font-weight: 600;
        }
        .jarvis-message .msg-content h1 { font-size: 1.2em; }
        .jarvis-message .msg-content h2 { font-size: 1.1em; }
        .jarvis-message .msg-content h3 { font-size: 1em; }
        .jarvis-message .msg-content strong {
            font-weight: 600;
        }
        .jarvis-message .msg-content a {
            color: var(--accent);
            text-decoration: none;
        }
        .jarvis-message .msg-content a:hover {
            text-decoration: underline;
        }
        
        .jarvis-chat-input-area {
            padding: 0.75rem 1rem 1rem;
            border-top: 1px solid var(--border);
        }
        
        .jarvis-typing-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingPulse {
            0%, 60%, 100% { opacity: 0.3; transform: scale(1); }
            30% { opacity: 1; transform: scale(1.2); }
        }
        
        .jarvis-input-row {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        
        .jarvis-chat-input {
            flex: 1;
            padding: 0.625rem 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-main);
            color: var(--text);
            font-size: 0.9rem;
            resize: none;
            min-height: 44px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
            font-family: inherit;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }
        
        .jarvis-chat-input::-webkit-scrollbar {
            width: 6px;
        }
        
        .jarvis-chat-input::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .jarvis-chat-input::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        
        .jarvis-chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .jarvis-send-btn {
            height: 44px;
            min-width: 44px;
            padding: 0 1rem;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .jarvis-send-btn:hover {
            background: #5855eb;
        }
        
        .jarvis-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .command-chat-messages {
            overflow-y: auto;
            padding: 1rem;
            height: 350px;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .command-chat-message {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            max-width: 85%;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .command-chat-message.from-user {
            background: rgba(34, 197, 94, 0.15);
            border-left: 3px solid var(--low);
            align-self: flex-end;
        }
        
        .command-chat-message.from-Jarvis {
            background: rgba(99, 102, 241, 0.15);
            border-left: 3px solid #6366f1;
            align-self: flex-start;
        }
        
        .command-chat-message.typing {
            color: var(--text-muted);
        }
        
        .typing-dots {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 0;
        }
        
        .typing-dots span {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: typing-bounce 1.4s ease-in-out infinite;
        }
        
        .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing-bounce {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-6px); opacity: 1; }
        }
        
        .command-chat-input-area {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .command-input-row {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }
        
        .command-chat-input-area .attach-btn {
            height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            box-sizing: border-box;
        }
        
        .command-chat-input-area .attach-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .command-chat-input {
            flex: 1;
            height: 44px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.6rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        
        .command-chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .command-chat-input-area .btn {
            height: 44px;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            font-size: 0.875rem;
        }
        
        .command-paste-preview {
            display: none;
            margin-bottom: 0.5rem;
            padding: 0.25rem;
        }
        
        .command-paste-preview.active {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .command-paste-preview .command-attachment-item img {
            max-width: 80px;
            max-height: 60px;
            border-radius: 6px;
            display: block;
        }
        
        .command-paste-preview .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: var(--critical);
            border: 2px solid var(--bg-card);
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 12px;
            line-height: 14px;
            text-align: center;
            padding: 0;
            font-weight: bold;
        }
        
        .command-paste-preview .remove-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .command-file-name {
            font-size: 0.8rem;
            color: var(--text-muted);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .command-attachment-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: rgba(0, 180, 216, 0.1);
            border-radius: 4px;
            font-size: 0.8rem;
        }
        
        .command-attachment-item .remove-attachment {
            background: none;
            border: none;
            color: var(--critical);
            cursor: pointer;
            font-size: 0.9rem;
            line-height: 1;
        }
        
        .command-close-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 1rem;
            cursor: pointer;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        
        .command-close-btn:hover {
            color: var(--text);
            border-color: var(--text-muted);
        }
        
        .command-bar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
        }
        
        .command-bar-overlay.active {
            display: block;
        }
        
        .command-expand-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 1rem;
            cursor: pointer;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 6px;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .command-expand-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .command-action-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 0.8rem;
            cursor: pointer;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 6px;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .command-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        .command-header-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }
        
        .session-selector {
            background: var(--bg-dark);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            cursor: pointer;
            min-width: 160px;
        }
        
        .session-selector:hover {
            border-color: var(--accent);
        }
        
        .session-selector:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        /* Thinking indicator - matches ai-working style with dot + icon */
        .thinking-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.3));
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 8px;
            animation: ai-glow 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.4), inset 0 0 10px rgba(139, 92, 246, 0.1);
        }
        
        .thinking-indicator .ai-working-icon {
            font-size: 1rem;
            line-height: 1;
        }
        
        @keyframes thinking-pulse {
            0%, 100% { 
                opacity: 0.5;
                filter: drop-shadow(0 0 2px var(--accent));
            }
            50% { 
                opacity: 1;
                filter: drop-shadow(0 0 8px var(--accent)) drop-shadow(0 0 12px var(--accent));
            }
        }
        
        /* Collapsed command bar thinking indicator */
        .thinking-indicator-collapsed {
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
        }
        .thinking-indicator-collapsed .thinking-pulse {
            width: 10px;
            height: 10px;
            background: var(--accent);
            border-radius: 50%;
            animation: collapsed-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 8px var(--accent), 0 0 16px var(--accent);
        }
        @keyframes collapsed-pulse {
            0%, 100% { 
                transform: scale(0.8);
                opacity: 0.6;
                box-shadow: 0 0 4px var(--accent);
            }
            50% { 
                transform: scale(1.2);
                opacity: 1;
                box-shadow: 0 0 12px var(--accent), 0 0 20px var(--accent);
            }
        }
        
        /* Stop buttons - icon only, SQUARE (equal width/height) */
        .stop-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--critical);
            color: var(--critical);
            border-radius: 6px;
            width: 28px;
            height: 28px;
            padding: 0;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stop-btn:hover {
            background: var(--critical);
            color: white;
        }
        
        .stop-btn-mini {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--critical);
            color: var(--critical);
            border-radius: 4px;
            width: 24px;
            height: 24px;
            padding: 0;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stop-btn-mini:hover {
            background: var(--critical);
            color: white;
        }
        
        .stop-icon-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--critical);
            color: var(--critical);
            border-radius: 4px;
            width: 24px;
            height: 24px;
            padding: 0;
            cursor: pointer;
            font-size: 0.85rem;
            line-height: 1;
            transition: all 0.15s;
            margin-left: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .stop-icon-btn:hover {
            background: var(--critical);
            color: white;
        }
        
        .stop-all-btn:hover {
            background: #dc2626;
        }
        
        /* Confirmation Modal */
        .confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 500;
            justify-content: center;
            align-items: center;
        }
        
        .confirm-modal.active {
            display: flex;
        }
        
        .confirm-dialog {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .confirm-dialog h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.1rem;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .confirm-dialog p {
            margin: 0 0 1.25rem 0;
            color: var(--text-muted);
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .confirm-dialog-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        
        .confirm-dialog .btn-cancel {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
        }
        
        .confirm-dialog .btn-cancel:hover {
            border-color: var(--text-muted);
        }
        
        .confirm-dialog .btn-confirm {
            background: var(--critical);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .confirm-dialog .btn-confirm:hover {
            background: #dc2626;
        }
        
        /* Session selector with actions */
        .session-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .session-action-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        
        .session-action-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .session-action-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .session-action-btn:disabled:hover {
            border-color: var(--border);
            color: var(--text-muted);
        }
        
        .session-action-btn.danger:hover {
            border-color: var(--critical);
            color: var(--critical);
        }
        
        /* Legacy classes for backwards compat */
        .session-edit-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem;
            opacity: 0.6;
            transition: all 0.15s;
        }
        
        .session-edit-btn:hover {
            color: var(--accent);
            opacity: 1;
        }
        
        .session-delete-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem;
            opacity: 0.6;
            transition: all 0.15s;
        }
        
        .session-delete-btn:hover {
            color: var(--critical);
            opacity: 1;
        }
        
        .new-session-btn {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--accent);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.15s;
        }
        
        .new-session-btn:hover {
            border-color: var(--accent);
            background: rgba(0, 180, 216, 0.1);
        }
        
        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background 0.2s;
        }
        
        .btn:hover { background: var(--accent-hover); }
        .btn-danger { background: var(--critical); }
        .btn-secondary { background: var(--bg-dark); border: 1px solid var(--border); }
        
        .help-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        
        .help-btn:hover {
            background: var(--bg-column);
            color: var(--accent);
            border-color: var(--accent);
        }
        
        .filter-select {
            background: var(--bg-dark);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }
        
        /* Agent Legend */
        .agent-legend {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.25rem 0.75rem;
            background: var(--bg-dark);
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            cursor: default;
        }
        
        .legend-item .icon {
            font-size: 1rem;
        }
        
        .legend-item .name {
            opacity: 0.8;
        }
        
        /* Agent icon in card */
        .agent-icon {
            font-size: 1.1rem;
            line-height: 1;
        }
        
        /* Board */
        .board {
            display: flex;
            gap: 1rem;
            padding: 1.5rem;
            overflow-x: auto;
            overflow-y: hidden;
            height: calc(100vh - 73px);
        }
        
        .column {
            flex: 1 0 300px;
            min-width: 300px;
            background: var(--bg-column);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 120px);
        }
        
        .column-header {
            padding: 1rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        
        .column-header .count {
            background: var(--bg-dark);
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .column-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .column-sort {
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            outline: none;
        }
        
        .column-sort:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        
        .column-sort:focus {
            border-color: var(--accent);
        }
        
        .column-cards {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .card:hover {
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        
        .card-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            padding-right: 1.5rem;
        }
        
        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            font-size: 0.75rem;
        }
        
        .tag {
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            background: var(--bg-dark);
        }
        
        .tag.priority-Critical { background: var(--critical); color: white; }
        .tag.priority-High { background: var(--high); color: white; }
        .tag.priority-Medium { background: var(--medium); color: black; }
        .tag.priority-Low { background: var(--low); color: white; }
        
        /* Agent colors */
        .tag.agent-Jarvis { background: #6366f1; color: white; }
        .tag.agent-Jarvis { background: #0ea5e9; color: white; }
        .tag.agent-Architect { background: #8b5cf6; color: white; }
        .tag.agent-Security-Auditor { background: #ef4444; color: white; }
        .tag.agent-Code-Reviewer { background: #14b8a6; color: white; }
        .tag.agent-UX-Manager { background: #ec4899; color: white; }
        .tag.agent-User { background: #22c55e; color: white; }
        .tag.agent-Unassigned { background: #64748b; color: white; }
        
        /* Notification bubble */
        .notification-bubble {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--critical);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }
        
        /* Action Items */
        .action-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            background: var(--bg-card);
            border-radius: 6px;
            border-left: 3px solid var(--accent);
            cursor: pointer;
            transition: all 0.15s;
        }
        .action-item:hover {
            background: rgba(255, 255, 255, 0.03);
            transform: translateX(2px);
        }
        .action-item.type-question { border-left-color: #f59e0b; }
        .action-item.type-completion { border-left-color: #10b981; }
        .action-item.type-blocker { border-left-color: #ef4444; }
        .action-item-check {
            width: 18px;
            height: 18px;
            border: 2px solid var(--text-muted);
            border-radius: 4px;
            flex-shrink: 0;
            margin-top: 2px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .action-item-check:hover {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.2);
        }
        .action-item-content {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--text);
        }
        .action-item-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.35rem;
        }
        .action-item-type {
            font-size: 0.6rem;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.03em;
        }
        .action-item-type.question { background: rgba(245, 158, 11, 0.2); color: #f59e0b; }
        .action-item-type.completion { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .action-item-type.blocker { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        
        .action-item.resolved {
            opacity: 0.5;
            border-left-color: var(--text-muted) !important;
        }
        .action-item.resolved .action-item-content {
            text-decoration: line-through;
        }
        .action-item.resolved .action-item-check {
            background: var(--text-muted);
            border-color: var(--text-muted);
            cursor: pointer;
        }
        .action-item.resolved .action-item-check:hover {
            background: var(--bg-dark);
            border-color: var(--accent);
        }
        .action-item-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .action-item:hover .action-item-actions {
            opacity: 1;
        }
        .action-item-archive,
        .action-item-delete {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .action-item-archive {
            color: var(--text-muted);
        }
        .action-item-archive:hover {
            color: var(--accent);
            background: rgba(0, 180, 216, 0.15);
        }
        .action-item-delete {
            color: var(--critical);
        }
        .action-item-delete:hover {
            background: rgba(239, 68, 68, 0.15);
        }
        
        /* Action Items Section Container */
        #actionItemsSection {
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 250px;
        }
        
        #actionItemsSection.collapsed {
            padding: 0.75rem 1rem !important;
            max-height: none;
            overflow: visible;
        }
        
        #actionItemsSection.collapsed .action-items-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        /* Action Items Section Header - Simplified */
        .action-items-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        .action-items-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem;
            margin: -0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }
        .action-items-header-left:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        .action-items-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
        }
        .action-items-count {
            background: var(--bg-dark);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-muted);
        }
        .action-items-header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .action-items-collapse-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0.15rem 0.35rem;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .action-items-collapse-btn:hover {
            color: var(--text);
            background: var(--bg-dark);
        }
        .action-items-archive-toggle {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            transition: all 0.15s;
            opacity: 0.7;
        }
        .action-items-header:hover .action-items-archive-toggle {
            opacity: 1;
        }
        .action-items-archive-toggle:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        .action-items-archive-toggle.active {
            background: rgba(0, 180, 216, 0.15);
            border-color: var(--accent);
            color: var(--accent);
            opacity: 1;
        }
        
        /* Collapsible section */
        .action-items-content {
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
        }
        .action-items-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            overflow: hidden;
            margin: 0;
        }
        
        /* Archive viewer */
        .archive-viewer {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border);
        }
        .archive-viewer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
        .archive-viewer .action-item {
            opacity: 0.6;
            font-size: 0.85em;
        }
        .action-item-unarchive {
            background: none;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .action-item-unarchive:hover {
            background: rgba(0, 180, 216, 0.15);
        }
        
        /* AI Working Indicator - Compact Icon Edition */
        .ai-working {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.3));
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 8px;
            animation: ai-glow 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.4), inset 0 0 10px rgba(139, 92, 246, 0.1);
            cursor: default;
        }
        .ai-working-dot {
            width: 6px;
            height: 6px;
            background: linear-gradient(135deg, #a78bfa, #f472b6);
            border-radius: 50%;
            animation: ai-dot-spin 1s linear infinite, ai-dot-pulse 0.5s ease-in-out infinite alternate;
            box-shadow: 0 0 10px #a78bfa, 0 0 20px rgba(139, 92, 246, 0.5);
        }
        .ai-working-icon {
            font-size: 0.9rem;
            line-height: 1;
        }
        @keyframes ai-glow {
            0%, 100% { 
                box-shadow: 0 0 15px rgba(139, 92, 246, 0.4), inset 0 0 10px rgba(139, 92, 246, 0.1);
                border-color: rgba(139, 92, 246, 0.5);
            }
            50% { 
                box-shadow: 0 0 25px rgba(139, 92, 246, 0.7), 0 0 40px rgba(236, 72, 153, 0.3), inset 0 0 15px rgba(139, 92, 246, 0.2);
                border-color: rgba(236, 72, 153, 0.7);
            }
        }
        @keyframes ai-dot-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes ai-dot-pulse {
            0% { transform: scale(0.8); opacity: 0.7; }
            100% { transform: scale(1.2); opacity: 1; }
        }
        
        /* Subtle card highlight when AI is working */
        .card:has(.ai-working) {
            border-color: rgba(139, 92, 246, 0.4);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.15);
        }
        
        /* Chat working indicator in task modal */
        .chat-working-indicator {
            display: flex;
            align-items: center;
            padding: 0.25rem 0.5rem;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 12px;
            animation: ai-glow 2s ease-in-out infinite;
        }
        
        /* Chat working agent item - matches card style */
        .chat-working-agent {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .chat-working-agent .ai-working-dot {
            width: 5px;
            height: 5px;
        }
        
        .chat-working-agent .ai-working-icon {
            font-size: 0.8rem;
        }
        
        /* Modal - Normal Mode */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }
        
        .modal-overlay.active { display: flex; }
        
        .modal {
            background: var(--bg-card);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            min-height: 500px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        .modal.new-task-mode {
            min-height: auto;
            max-height: 80vh;
        }
        
        .modal.new-task-mode .modal-body {
            overflow: visible;
        }
        
        .modal.new-task-mode .task-details {
            padding-bottom: 1.5rem;
        }
        
        /* Modal - Theater Mode */
        .modal.theater-mode {
            max-width: 95vw;
            max-height: calc(100vh - 2rem);
            width: 95vw;
            height: calc(100vh - 2rem);
            margin: 1rem;
        }
        
        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-radius: 16px 16px 0 0;
        }
        
        .modal-header h2 {
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Title input in modal header - looks like standard text box */
        .modal-title-input {
            flex: 1;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            margin-right: 1rem;
            outline: none;
            transition: border-color 0.15s;
        }
        
        .modal-title-input:hover {
            border-color: var(--text-muted);
        }
        
        .modal-title-input:focus {
            border-color: var(--accent);
        }
        
        .modal-title-input::placeholder {
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .modal-header-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .modal-header-actions button {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }
        
        .modal-header-actions button:hover {
            background: var(--bg-dark);
            color: var(--text);
        }
        
        .header-delete-btn:hover {
            color: var(--danger) !important;
            background: rgba(239, 68, 68, 0.1) !important;
        }
        
        .header-save-btn:hover {
            color: var(--success) !important;
            background: rgba(34, 197, 94, 0.1) !important;
        }
        
        /* Save button states */
        .header-save-btn .save-icon {
            display: block;
        }
        
        .header-save-btn .save-spinner {
            display: none;
            animation: spin 0.8s linear infinite;
        }
        
        .header-save-btn.saving .save-icon {
            display: none !important;
        }
        
        .header-save-btn.saving .save-spinner {
            display: block !important;
        }
        
        .header-save-btn.saved {
            animation: saveGlow 0.6s ease-out;
        }
        
        .header-save-btn.saved .save-icon {
            display: block !important;
            stroke: var(--success);
        }
        
        @keyframes saveGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
                background: rgba(34, 197, 94, 0.15);
            }
            50% {
                box-shadow: 0 0 12px 4px rgba(34, 197, 94, 0.5);
                background: rgba(34, 197, 94, 0.2);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
                background: transparent;
            }
        }
        
        .modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            min-height: 0;
            padding-bottom: 0;
        }
        
        .modal-body:has(.task-details.collapsed) {
            overflow: hidden;
        }
        
        /* Task Details Section */
        .task-details {
            padding: 1.25rem 1.5rem;
            border-bottom: none;
        }
        
        .task-details.collapsed {
            display: none;
        }
        
        /* When details are collapsed, expand chat to fill */
        .task-details.collapsed + .resize-handle + .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-top: 0;
            min-height: 0;
            overflow: hidden;
        }
        
        .task-details.collapsed + .resize-handle + .chat-section .chat-header {
            border-top: none;
            flex-shrink: 0;
        }
        
        .task-details.collapsed + .resize-handle + .chat-section .chat-messages {
            flex: 1 1 0;
            max-height: calc(90vh - 230px) !important;
            min-height: 0;
            overflow-y: scroll !important;
        }
        
        .task-details.collapsed + .resize-handle + .chat-section .chat-input-area {
            flex-shrink: 0;
        }
        
        /* Resize Handle between Details and Chat - Hidden */
        .resize-handle {
            display: none;
        }
        
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.25rem;
        }
        
        .form-group {
            flex: 1;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.35rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: color 0.15s;
        }
        
        .form-group:focus-within label {
            color: var(--accent);
        }
        
        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.625rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: inherit;
        }
        
        .form-group textarea {
            min-height: 80px;
            resize: vertical;
            line-height: 1.6;
        }
        
        /* Style the resize handle for dark mode */
        .form-group textarea::-webkit-resizer {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 0 0 4px 0;
        }
        
        /* Title input - slightly larger but not heading-like */
        #taskTitleInput {
            font-size: 1rem;
            font-weight: 500;
        }
        
        #taskTitleInput:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        /* Description styling */
        #taskDescription::placeholder {
            color: var(--text-muted);
        }
        
        /* Ghost danger button for destructive actions */
        .btn-ghost-danger {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.15s;
        }
        
        .btn-ghost-danger:hover {
            border-color: var(--critical);
            color: var(--critical);
            background: rgba(239, 68, 68, 0.1);
        }
        
        /* Modal footer - restructured for safe button placement */
        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .modal-footer-left {
            display: flex;
            gap: 0.5rem;
        }
        
        .modal-footer-right {
            display: flex;
            gap: 0.75rem;
        }
        
        /* Chat Section - Part of scrollable content */
        .chat-section {
            display: block;
            margin-top: 1rem;
        }
        
        .chat-header {
            padding: 0.75rem 1.5rem;
            background: var(--bg-column);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 600;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        /* Messages container - bordered box, scrollable */
        .chat-messages {
            padding: 1rem;
            margin: 1rem 1.5rem 0.75rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
            background: linear-gradient(180deg, var(--bg-dark) 0%, rgba(15, 23, 42, 0.8) 100%);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .chat-messages.loading::after {
            content: '';
            display: block;
            width: 20px;
            height: 20px;
            margin: 1rem auto;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Theater Mode - Full expansion */
        .theater-mode .modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding-bottom: 0;
            overflow: hidden !important;
            min-height: 0;
        }
        
        .theater-mode .task-details {
            flex-shrink: 0;
            max-height: 40vh;
            overflow-y: auto;
        }
        
        .theater-mode .task-details.collapsed {
            display: none;
        }
        
        .theater-mode .task-details.collapsed + .resize-handle + .chat-section {
            margin-top: 0;
        }
        
        .theater-mode .chat-section {
            flex: 1 1 0 !important;
            display: flex;
            flex-direction: column;
            min-height: 0 !important;
            margin-top: 0;
            overflow: hidden;
        }
        
        .theater-mode .chat-header {
            flex: 0 0 auto;
            padding: 0.5rem 1.5rem;
        }
        
        .theater-mode .chat-messages {
            flex: 1 1 0;
            min-height: 0;
            margin: 0.25rem 1.5rem 0.25rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: linear-gradient(180deg, var(--bg-dark) 0%, rgba(15, 23, 42, 0.8) 100%);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-y: auto !important;
        }
        
        .theater-mode .chat-input-area {
            flex: 0 0 auto;
            padding: 0.25rem 1.5rem 0.25rem 1.5rem;
            background: var(--bg-card);
            border-radius: 0 0 16px 16px;
        }
        
        .theater-mode .chat-input {
            max-height: 200px !important;
            overflow-y: auto !important;
        }
        
        .chat-message {
            background: var(--bg-dark);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            max-width: 85%;
            align-self: flex-start;
            border-left: 3px solid var(--border);
        }
        
        .chat-message.from-jarvis {
            background: rgba(99, 102, 241, 0.15);
            border-left: 3px solid #6366f1;
        }
        
        .chat-message.from-architect {
            background: rgba(168, 85, 247, 0.15);
            border-left: 3px solid #a855f7;
        }
        
        .chat-message.from-security-auditor {
            background: rgba(239, 68, 68, 0.15);
            border-left: 3px solid #ef4444;
        }
        
        .chat-message.from-code-reviewer {
            background: rgba(34, 197, 94, 0.15);
            border-left: 3px solid #22c55e;
        }
        
        .chat-message.from-ux-manager {
            background: rgba(236, 72, 153, 0.15);
            border-left: 3px solid #ec4899;
        }
        
        .chat-message.from-system {
            background: rgba(100, 116, 139, 0.15);
            border-left: 3px solid #64748b;
            font-style: italic;
        }
        
        .chat-message.from-user {
            background: rgba(0, 180, 216, 0.15);
            border-left: none;
            border-right: 3px solid var(--accent);
            align-self: flex-end;
            border-radius: 8px;
        }
        
        .chat-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
        }
        
        .chat-message-header .agent {
            font-weight: 600;
            color: var(--accent);
        }
        
        .chat-message.from-user .chat-message-header .agent {
            color: var(--accent);
        }
        
        .chat-message.from-jarvis .chat-message-header .agent { color: #6366f1; }
        .chat-message.from-architect .chat-message-header .agent { color: #a855f7; }
        .chat-message.from-security-auditor .chat-message-header .agent { color: #ef4444; }
        .chat-message.from-code-reviewer .chat-message-header .agent { color: #22c55e; }
        .chat-message.from-ux-manager .chat-message-header .agent { color: #ec4899; }
        .chat-message.from-system .chat-message-header .agent { color: #64748b; }
        
        .chat-message-header .time {
            color: var(--text-muted);
        }
        
        .chat-message-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .msg-actions {
            margin-left: auto;
            display: flex;
            gap: 0.25rem;
        }
        
        .msg-action-btn {
            background: transparent;
            border: 1px solid var(--border);
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
            border-radius: 4px;
            opacity: 0.7;
            transition: opacity 0.2s, background 0.2s;
        }
        
        .msg-action-btn:hover {
            opacity: 1;
            background: var(--bg-dark);
        }
        
        /* Export checkbox column - WhatsApp style */
        .chat-message {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }
        
        .export-checkbox-col {
            display: none;
            flex-shrink: 0;
            padding-top: 0.5rem;
        }
        
        .export-mode .export-checkbox-col {
            display: block;
        }
        
        .export-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
        }
        
        .chat-message-body {
            flex: 1;
            min-width: 0;
        }
        
        /* Command bar chat message structure */
        .jarvis-message {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }
        
        .command-export-checkbox-col {
            display: none;
            flex-shrink: 0;
            padding-top: 0.25rem;
        }
        
        .export-mode .command-export-checkbox-col {
            display: block;
        }
        
        .command-export-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--accent);
        }
        
        .jarvis-message-body {
            flex: 1;
            min-width: 0;
        }
        
        .jarvis-message .msg-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .jarvis-message .msg-actions {
            display: flex;
            gap: 0.25rem;
        }
        
        .reply-preview-container {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin-bottom: 0.5rem;
        }
        
        .reply-preview {
            background: var(--bg-dark);
            border-left: 3px solid var(--accent);
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }
        
        .reply-preview-text {
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        
        .reply-preview-close {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0;
            line-height: 1;
        }
        
        .reply-preview-close:hover {
            color: var(--danger, #dc3545);
        }
        
        .reply-clear-all {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            align-self: flex-end;
        }
        
        .reply-clear-all:hover {
            background: var(--bg-dark);
        }
        
        .chat-message-content img {
            max-width: min(100%, 400px);
            max-height: 300px;
            object-fit: contain;
            border-radius: 6px;
            margin-top: 0.5rem;
            cursor: pointer;
        }
        
        .chat-message-content img:hover {
            opacity: 0.9;
        }
        
        /* Markdown styles for chat */
        .chat-message-content p {
            margin: 0 0 0.5rem 0;
        }
        .chat-message-content p:last-child {
            margin-bottom: 0;
        }
        .chat-message-content code {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em;
        }
        .chat-message-content pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 0.5rem 0;
        }
        .chat-message-content pre code {
            background: none;
            padding: 0;
        }
        .chat-message-content ul, .chat-message-content ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .chat-message-content li {
            margin: 0.25rem 0;
        }
        .chat-message-content blockquote {
            border-left: 3px solid var(--accent);
            margin: 0.5rem 0;
            padding-left: 0.75rem;
            color: var(--text-muted);
        }
        .chat-message-content table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        .chat-message-content th, .chat-message-content td {
            border: 1px solid var(--border);
            padding: 0.5rem;
            text-align: left;
        }
        .chat-message-content th {
            background: rgba(0, 0, 0, 0.2);
        }
        .chat-message-content h1, .chat-message-content h2, .chat-message-content h3 {
            margin: 0.75rem 0 0.5rem 0;
            font-weight: 600;
        }
        .chat-message-content h1 { font-size: 1.25em; }
        .chat-message-content h2 { font-size: 1.15em; }
        .chat-message-content h3 { font-size: 1.05em; }
        
        /* Chat Input - Inside scrollable content */
        .chat-input-area {
            padding: 0 1.5rem 1rem 1.5rem;
            background: var(--bg-card);
            border-radius: 0 0 16px 16px;
        }
        
        .chat-input-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
        }
        
        .chat-input-wrapper .attach-btn,
        .chat-input-wrapper .mention-btn {
            height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        .chat-input-wrapper .btn {
            height: 44px;
            padding: 0 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-sizing: border-box;
            font-size: 0.875rem;
        }
        
        .chat-input-wrapper .chat-input-box {
            flex: 1;
            display: flex;
            align-items: flex-end;
            min-height: 44px;
        }
        
        .chat-input-wrapper .chat-input {
            width: 100%;
            min-height: 44px;
            max-height: 150px;
            padding: 12px 0.75rem;
            resize: none;
            box-sizing: border-box;
        }
        
        .chat-input-box {
            flex: 1;
            position: relative;
        }
        
        .chat-input {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 12px 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
            line-height: 1.4;
            resize: vertical;
            min-height: 44px;
            max-height: 300px;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }
        
        .chat-input::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-input::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-input::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }
        
        .chat-input::-webkit-scrollbar-corner {
            background: transparent;
        }
        
        .chat-input::-webkit-resizer {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 0 0 4px 0;
        }
        
        .theater-mode .chat-input {
            resize: vertical;
            max-height: 400px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .paste-preview {
            display: none;
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            gap: 0.5rem;
        }
        
        .paste-preview.active {
            display: flex;
            flex-wrap: wrap;
        }
        
        .paste-preview .paste-preview-item {
            position: relative;
        }
        
        .paste-preview img {
            max-width: 80px;
            max-height: 60px;
            border-radius: 6px;
            display: block;
        }
        
        .paste-preview .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: var(--critical);
            border: 2px solid var(--bg-card);
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 12px;
            line-height: 14px;
            text-align: center;
            padding: 0;
            font-weight: bold;
        }
        
        .paste-preview .remove-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .attach-btn {
            height: 44px;
            min-width: 44px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.25rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        
        .attach-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Modal Footer */
        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }
        
        /* Drag and drop */
        .card.dragging { opacity: 0.5; }
        .column.drag-over { background: rgba(0, 180, 216, 0.1); }
        .card.drag-above { border-top: 2px solid var(--accent); margin-top: -2px; }
        .card.drag-below { border-bottom: 2px solid var(--accent); margin-bottom: -2px; }
        
        /* Empty state */
        .empty-chat {
            text-align: center;
            color: var(--text-muted);
            padding: 2rem;
        }
        
        /* File input hidden */
        .file-input { display: none; }
        
        /* Help Modal Styles */
        .help-content {
            color: var(--text);
            line-height: 1.6;
        }
        
        .help-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        .help-section:last-child {
            border-bottom: none;
        }
        
        .help-section h3 {
            color: var(--accent);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }
        
        .help-section p {
            margin-bottom: 0.5rem;
        }
        
        .help-section ul, .help-section ol {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .help-section li {
            margin-bottom: 0.35rem;
        }
        
        .help-flow {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.75rem 0;
            flex-wrap: wrap;
        }
        
        .flow-stage {
            background: var(--bg-dark);
            padding: 0.35rem 0.75rem;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.85rem;
        }
        
        .flow-note {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
        }
        
        .agent-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .agent-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0;
        }
        
        .agent-item span {
            font-size: 1.1rem;
        }
        
        .help-note {
            background: rgba(0, 180, 216, 0.1);
            border-left: 3px solid var(--accent);
            padding: 0.75rem;
            margin-top: 0.75rem;
            border-radius: 0 4px 4px 0;
            font-size: 0.9rem;
        }
        
        /* Mention Button */
        .mention-btn {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.15s;
        }
        
        .mention-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        /* Mention Dropdown */
        .mention-dropdown {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.4);
            margin-bottom: 0.5rem;
            min-width: 200px;
            z-index: 50;
        }
        
        .mention-dropdown.active {
            display: block;
        }
        
        .mention-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .mention-option:hover {
            background: var(--bg-dark);
        }
        
        .mention-option:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .mention-option:last-child {
            border-radius: 0 0 8px 8px;
        }
        
        .chat-input-wrapper {
            position: relative;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 8px;"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/><line x1="12" y1="2" x2="12" y2="22" opacity="0.3"/></svg><span>DEV</span> Task Board</h1>
        
        <!-- Molt Command Bar -->
        <div class="command-bar" id="commandBar" onclick="expandCommandBar()">
            <div class="command-bar-collapsed" id="commandBarCollapsed">
                <span class="command-bar-icon" id="commandBarIcon"></span>
                <span class="thinking-indicator-collapsed" id="jarvisThinkingCollapsed" style="display: none;" title="Jarvis is thinking...">
                    <span class="thinking-pulse"></span>
                </span>
                <span class="command-bar-preview" id="commandBarPreview">Ask Jarvis anything...</span>
                <button class="stop-icon-btn" id="stopAllBtn" onclick="event.stopPropagation(); stopAllAgents()" title="Stop all agents"></button>
            </div>
            <div class="command-bar-expanded" id="commandBarExpanded">
                <div class="command-header">
                    <div class="command-header-title">
                        <div class="session-selector-wrapper">
                            <select id="sessionSelector" class="session-selector" onchange="switchSession(this.value)" onclick="event.stopPropagation()">
                                <option value="main">Jarvis (Main)</option>
                            </select>
                            <button class="session-action-btn danger" id="deleteSessionBtn" onclick="event.stopPropagation(); deleteCurrentSession()" title="Close this session"></button>
                        </div>
                        <button class="new-session-btn" onclick="event.stopPropagation(); createNewSession()" title="New session">+ New</button>
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <span class="thinking-indicator" id="jarvisThinking" style="display: none;"><span class="ai-working-dot"></span><span class="ai-working-icon"></span></span>
                        <button class="stop-btn" id="stopSessionBtn" onclick="event.stopPropagation(); stopCurrentSession()" title="Stop this session"></button>
                        <button class="command-action-btn" onclick="event.stopPropagation(); toggleCommandBarExportMode()" title="Export to MD"></button>
                        <button class="command-expand-btn" onclick="event.stopPropagation(); toggleCommandFullsize()" title="Fullscreen" id="commandExpandBtn"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><polyline points="21 3 14 10"/><polyline points="3 21 10 14"/></svg></button>
                        <button class="command-close-btn" onclick="event.stopPropagation(); collapseCommandBar()"></button>
                    </div>
                </div>
                <!-- Native Jarvis Chat - v1.8 -->
                <div class="jarvis-chat-container" id="jarvisChatContainer">
                    <div class="jarvis-chat-messages" id="jarvisChatMessages">
                        <!-- Messages rendered here -->
                    </div>
                    <div class="jarvis-chat-input-area">
                        <div class="command-paste-preview" id="commandPastePreview"></div>
                        <div class="jarvis-input-row">
                            <button class="attach-btn" onclick="document.getElementById('commandFileInput').click()" title="Attach file"></button>
                            <input type="file" id="commandFileInput" class="file-input" accept="image/*,.pdf,.txt,.md,.json,.csv" onchange="handleCommandFileSelect(event)" multiple>
                            <textarea 
                                id="jarvisChatInput" 
                                class="jarvis-chat-input" 
                                placeholder="Ctrl+V to paste images  Shift+Enter for new line"
                                rows="1"
                                onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendJarvisMessage(); }"
                                oninput="this.style.height = 'auto'; this.style.height = Math.min(this.scrollHeight, 150) + 'px';"
                            ></textarea>
                            <button class="jarvis-send-btn" onclick="sendJarvisMessage()" id="jarvisSendBtn">
                                <span></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="header-actions">
            <div class="agent-legend" id="agentLegend"></div>
            <select class="filter-select" id="filterAgent">
                <option value="">All Agents</option>
            </select>
            <button class="btn" onclick="openNewTaskModal()">+ New Task</button>
            <button class="help-btn" onclick="openHelpModal()" title="Help"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></button>
        </div>
    </header>
    
    <div class="board" id="board"></div>
    
    <!-- Command Bar Overlay -->
    <div class="command-bar-overlay" id="commandBarOverlay" onclick="collapseCommandBar()"></div>
    
    <!-- Confirmation Modal -->
    <div class="confirm-modal" id="confirmModal">
        <div class="confirm-dialog">
            <h3 id="confirmTitle">Confirm</h3>
            <p id="confirmMessage">Are you sure?</p>
            <div class="confirm-dialog-actions">
                <button class="btn-cancel" onclick="closeConfirmModal()">Cancel</button>
                <button class="btn-confirm" id="confirmBtn" onclick="executeConfirmAction()">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Input Modal (for naming sessions) -->
    <div class="confirm-modal" id="renameModal">
        <div class="confirm-dialog">
            <h3 id="renameModalTitle">Session Name</h3>
            <input type="text" id="renameInput" style="width: 100%; padding: 0.5rem; margin: 0.5rem 0 1rem 0; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-dark); color: var(--text); font-size: 0.9rem;" onkeydown="if(event.key === 'Enter') executeRename()">
            <div class="confirm-dialog-actions">
                <button class="btn-cancel" onclick="closeRenameModal()">Cancel</button>
                <button class="btn-confirm" id="renameModalBtn" onclick="executeRename()">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal" style="max-width: 800px; max-height: 90vh;">
            <div class="modal-header">
                <h2><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 6px;"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/><line x1="12" y1="2" x2="12" y2="22" opacity="0.3"/></svg><span style="color: var(--accent);">DEV</span> Task Board Help</h2>
                <div class="modal-header-actions">
                    <button onclick="closeHelpModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body" style="overflow-y: auto; padding: 1.5rem;">
                <div class="help-content" id="helpContent">
                    <!-- Content populated by JS -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Task Modal -->
    <div class="modal-overlay" id="taskModal">
        <div class="modal" id="modalContainer">
            <div class="modal-header">
                <input type="text" id="taskTitleInput" class="modal-title-input" required placeholder="Task title..." form="taskForm">
                <div class="modal-header-actions">
                    <button onclick="confirmDeleteTask()" title="Delete Task" id="headerDeleteBtn" class="header-delete-btn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
                    <button onclick="saveTaskFromHeader()" title="Save Changes" id="headerSaveBtn" class="header-save-btn">
                        <svg class="save-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>
                        <svg class="save-spinner" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="10" stroke-dasharray="32" stroke-dashoffset="12"/></svg>
                    </button>
                    <button onclick="toggleTheaterMode()" title="Toggle Theater Mode" id="theaterBtn"></button>
                    <button onclick="closeModal()" title="Close">&times;</button>
                </div>
            </div>
            
            <div class="modal-body">
                <!-- Task Details (collapsible in theater mode) -->
                <div class="task-details" id="taskDetails">
                    <form id="taskForm" onsubmit="saveTask(event)">
                        <input type="hidden" id="taskId">
                        
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label>Description</label>
                            <textarea id="taskDescription" rows="3" placeholder="Add a description..."></textarea>
                        </div>
                        
                        <div class="form-row" style="margin-bottom: 0;">
                            <div class="form-group">
                                <label>Status</label>
                                <select id="taskStatus"></select>
                            </div>
                            <div class="form-group">
                                <label>Priority</label>
                                <select id="taskPriority"></select>
                            </div>
                            <div class="form-group">
                                <label>Assigned To</label>
                                <select id="taskAgent"></select>
                            </div>
                            <div class="form-group">
                                <label>Due Date</label>
                                <input type="date" id="taskDueDate">
                            </div>
                        </div>
                        
                        <div id="sourceInfo" style="display:none; margin-top: 0.75rem; padding: 0.5rem; background: var(--bg-dark); border-radius: 6px; font-size: 0.75rem;">
                            <span style="color: var(--text-muted);">Source:</span>
                            <a href="#" id="sourceLink" style="color: var(--accent); text-decoration: none;" onclick="openSourceFile()">
                                <span id="sourceRefText"></span>
                            </a>
                        </div>
                    </form>
                    
                    <!-- Action Items Section - Styled as card -->
                    <div id="actionItemsSection" style="margin: 1rem 0 0 0; padding: 1rem; background: rgba(0, 0, 0, 0.15); border-radius: 8px; border: 1px solid var(--border); display: none;">
                        <div class="action-items-header">
                            <div class="action-items-header-left" onclick="toggleActionItemsCollapse()" style="cursor: pointer;">
                                <button class="action-items-collapse-btn" id="actionItemsCollapseBtn" title="Collapse/expand"></button>
                                <span class="action-items-title">Action Items</span>
                                <span class="action-items-count" id="actionItemsCount"></span>
                            </div>
                            <div class="action-items-header-right">
                                <button class="action-items-archive-toggle" id="archiveToggleBtn" onclick="event.stopPropagation(); toggleArchiveView()" title="View archived items"> Archive</button>
                            </div>
                        </div>
                        <div class="action-items-content" id="actionItemsContent">
                            <div id="actionItemsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                            <div id="archiveViewer" class="archive-viewer" style="display: none;">
                                <div class="archive-viewer-header">
                                    <span> Archived Items</span>
                                    <span id="archiveCount"></span>
                                </div>
                                <div id="archivedItemsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Resize Handle -->
                <div class="resize-handle" id="resizeHandle" title="Drag to resize"></div>
                
                <!-- Chat Section (messages only - input is fixed below) -->
                <div class="chat-section" id="chatSection">
                    <div class="chat-header">
                        <span>Conversation</span>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <div class="chat-working-indicator" id="chatWorkingIndicator" style="display: none;" title="">
                                <div id="chatWorkingAgents" style="display: flex; gap: 0.25rem; align-items: center;"></div>
                            </div>
                            <button class="stop-btn-mini" id="stopAgentBtn" onclick="stopTaskAgent()" title="Stop agent"></button>
                            <button class="btn btn-secondary" onclick="toggleExportMode()" title="Export to MD" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"></button>
                            <button class="btn btn-secondary" onclick="toggleTaskDetails()" id="toggleDetailsBtn" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">Hide Details</button>
                        </div>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <div class="empty-chat">No messages yet. Start the conversation!</div>
                    </div>
                    
                    <!-- Chat Input Area - Inside scrollable content -->
                    <div class="chat-input-area">
                        <div class="paste-preview" id="pastePreview"></div>
                        <div class="chat-input-wrapper">
                            <div class="mention-dropdown" id="mentionDropdown"></div>
                            <button class="attach-btn" onclick="document.getElementById('fileInput').click()" title="Attach file"></button>
                            <input type="file" id="fileInput" class="file-input" accept="image/*,.pdf,.txt,.md,.json,.csv,.log" onchange="handleFileSelect(event)">
                            <button class="mention-btn" onclick="toggleMentionDropdown(event)" title="Tag an agent">@</button>
                            <div class="chat-input-box">
                                <textarea class="chat-input" id="chatInput" placeholder="CTRL+V | SHIFT+ENTER" rows="1" onkeydown="handleChatKeydown(event)" oninput="autoGrowChatInput(this)"></textarea>
                            </div>
                            <button class="btn" onclick="sendChatMessage()">Send</button>
                        </div>
                    </div>
                </div>
            </div>
            
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div class="confirm-modal" id="deleteConfirmModal">
        <div class="confirm-dialog" style="text-align: center; padding: 1.25rem 1.25rem 1rem;">
            <h3 style="margin: 0 0 0.5rem; color: var(--text); font-size: 1rem;">Delete Task?</h3>
            <p id="deleteTaskName" style="margin: 0 0 1rem; color: var(--text-muted); font-size: 0.85rem;">This action cannot be undone.</p>
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button class="btn btn-secondary" onclick="closeDeleteConfirm()">Cancel</button>
                <button class="btn btn-danger" onclick="executeDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const API = '';
        let config = { agents: [], statuses: [], priorities: [] };
        let tasks = [];
        let comments = {}; // taskId -> comments array
        let actionItems = {}; // taskId -> action items array
        let workingAgentsByTask = {}; // taskId -> Set of working agent names (for multi-agent display)
        let columnSortMode = {}; // status -> sort mode (latest|priority|agent|custom)
        let customSortOrder = {}; // status -> array of task IDs in custom order
        let pastedImages = []; // Array for multiple images
        let theaterMode = false;
        let detailsVisible = true;
        
        // Agent icons mapping (main agent added dynamically from config)
        window.AGENT_ICONS = {
            'Architect': '',
            'Security Auditor': '',
            'Code Reviewer': '',
            'UX Manager': '',
            'User': '',
            'Unassigned': ''
        };
        
        function getAgentIcon(agent) {
            return window.AGENT_ICONS[agent] || '';
        }
        
        // Timezone-aware date/time formatting (uses browser's detected timezone)
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        
        function formatDateTime(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleString(undefined, {
                timeZone: userTimezone,
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
        
        function formatTime(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleTimeString(undefined, {
                timeZone: userTimezone,
                hour: '2-digit',
                minute: '2-digit'
            });
        }
        
        function formatTimeNow() {
            const now = new Date();
            const date = now.toLocaleDateString(undefined, {
                timeZone: userTimezone,
                month: 'short',
                day: 'numeric'
            });
            const time = now.toLocaleTimeString(undefined, {
                timeZone: userTimezone,
                hour: '2-digit',
                minute: '2-digit'
            });
            return `${date}, ${time}`;
        }
        
        // Initialize
        async function init() {
            config = await fetch(`${API}/api/config`).then(r => r.json());
            applyBranding();
            populateSelects();
            await loadTasks();
            renderBoard();
            setupPasteHandler();
            setupCommandPasteHandler();
            // Pre-load sessions and chat history so it's ready when command bar opens
            loadSessions();
            loadJarvisHistory('main');
        }
        
        function applyBranding() {
            // Apply branding from config to DOM elements
            const b = config.branding || {};
            const mainAgent = b.mainAgentName || 'Assistant';
            const mainEmoji = b.mainAgentEmoji || '';
            const humanLabel = b.humanSupervisorLabel || 'User';
            
            // Update command bar icon
            const commandBarIcon = document.getElementById('commandBarIcon');
            if (commandBarIcon) commandBarIcon.textContent = mainEmoji;
            
            // Update placeholder text
            const preview = document.getElementById('commandBarPreview');
            if (preview) preview.textContent = `Ask ${mainAgent} anything...`;
            
            const chatInput = document.getElementById('jarvisChatInput');
            if (chatInput) chatInput.placeholder = `Ctrl+V to paste images  Shift+Enter for new line`;
            
            // Update typing indicator
            const typingText = document.querySelector('.typing-text');
            if (typingText) typingText.textContent = `${mainAgent} is thinking...`;
            
            // Update session selector default option
            const sessionSelector = document.getElementById('sessionSelector');
            if (sessionSelector && sessionSelector.options[0]) {
                sessionSelector.options[0].textContent = `${mainAgent} (Main)`;
            }
            
            // Update AGENT_ICONS with main agent (used by cards and legend)
            if (window.AGENT_ICONS) {
                AGENT_ICONS[mainAgent] = mainEmoji;
            }
            
            // Update AGENT_ICONS_MAP with main agent (used by mention dropdown)
            if (window.AGENT_ICONS_MAP) {
                AGENT_ICONS_MAP[mainAgent] = mainEmoji;
            }
            
            // Store branding globally for use elsewhere
            window.BRANDING = b;
        }
        
        function populateSelects() {
            const filterAgent = document.getElementById('filterAgent');
            config.agents.forEach(a => {
                filterAgent.innerHTML += `<option value="${a}">${getAgentIcon(a)} ${a}</option>`;
            });
            
            // Populate legend (skip Unassigned)
            const legend = document.getElementById('agentLegend');
            config.agents.filter(a => a !== 'Unassigned').forEach(a => {
                legend.innerHTML += `<div class="legend-item" title="${a}"><span class="icon">${getAgentIcon(a)}</span><span class="name">${a}</span></div>`;
            });
            
            const statusSelect = document.getElementById('taskStatus');
            const prioritySelect = document.getElementById('taskPriority');
            const agentSelect = document.getElementById('taskAgent');
            
            config.statuses.forEach(s => {
                statusSelect.innerHTML += `<option value="${s}">${s}</option>`;
            });
            
            config.priorities.forEach(p => {
                prioritySelect.innerHTML += `<option value="${p}">${p}</option>`;
            });
            
            config.agents.forEach(a => {
                agentSelect.innerHTML += `<option value="${a}">${getAgentIcon(a)} ${a}</option>`;
            });
        }
        
        async function loadTasks() {
            const agent = document.getElementById('filterAgent').value;
            const url = agent ? `${API}/api/tasks?agent=${agent}` : `${API}/api/tasks`;
            tasks = await fetch(url).then(r => r.json());
            
            // Load comments and action items
            for (const task of tasks) {
                const taskComments = await fetch(`${API}/api/tasks/${task.id}/comments`).then(r => r.json());
                comments[task.id] = taskComments;
                const taskActionItems = await fetch(`${API}/api/tasks/${task.id}/action-items`).then(r => r.json());
                actionItems[task.id] = taskActionItems;
            }
        }
        
        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            
            config.statuses.forEach(status => {
                let statusTasks = tasks.filter(t => t.status === status);
                const sortMode = columnSortMode[status] || 'latest';
                
                // Apply sorting
                statusTasks = sortTasksForColumn(statusTasks, status, sortMode);
                
                const column = document.createElement('div');
                column.className = 'column';
                column.dataset.status = status;
                
                column.innerHTML = `
                    <div class="column-header">
                        <div class="column-header-left">
                            <span>${status}</span>
                            <select class="column-sort" onchange="setColumnSort('${status}', this.value)" title="Sort by">
                                <option value="priority" ${sortMode === 'priority' ? 'selected' : ''}>Priority</option>
                                <option value="latest" ${sortMode === 'latest' ? 'selected' : ''}>Latest</option>
                                <option value="agent" ${sortMode === 'agent' ? 'selected' : ''}>Agent</option>
                                <option value="custom" ${sortMode === 'custom' ? 'selected' : ''}>Custom</option>
                            </select>
                        </div>
                        <span class="count">${statusTasks.length}</span>
                    </div>
                    <div class="column-cards" 
                         ondragover="handleDragOver(event)" 
                         ondrop="handleDrop(event, '${status}')">
                        ${statusTasks.map(t => renderCard(t)).join('')}
                    </div>
                `;
                
                board.appendChild(column);
            });
        }
        
        function sortTasksForColumn(tasksToSort, status, sortMode) {
            const sorted = [...tasksToSort];
            
            switch (sortMode) {
                case 'priority':
                    const priorityOrder = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3};
                    sorted.sort((a, b) => (priorityOrder[a.priority] ?? 99) - (priorityOrder[b.priority] ?? 99));
                    break;
                    
                case 'latest':
                    // Sort by most recent comment or updated_at
                    sorted.sort((a, b) => {
                        const aComments = comments[a.id] || [];
                        const bComments = comments[b.id] || [];
                        const aLatest = aComments.length > 0 ? aComments[aComments.length - 1].created_at : a.updated_at;
                        const bLatest = bComments.length > 0 ? bComments[bComments.length - 1].created_at : b.updated_at;
                        return new Date(bLatest) - new Date(aLatest); // Descending (newest first)
                    });
                    break;
                    
                case 'agent':
                    sorted.sort((a, b) => (a.agent || '').localeCompare(b.agent || ''));
                    break;
                    
                case 'custom':
                    const order = customSortOrder[status] || [];
                    if (order.length > 0) {
                        sorted.sort((a, b) => {
                            const aIdx = order.indexOf(a.id);
                            const bIdx = order.indexOf(b.id);
                            // Tasks not in order go to end
                            const aPos = aIdx === -1 ? 9999 : aIdx;
                            const bPos = bIdx === -1 ? 9999 : bIdx;
                            return aPos - bPos;
                        });
                    }
                    break;
            }
            
            return sorted;
        }
        
        function setColumnSort(status, mode) {
            columnSortMode[status] = mode;
            // Clear custom order when switching away from custom
            if (mode !== 'custom') {
                delete customSortOrder[status];
            }
            renderBoard();
        }
        
        function renderCard(task) {
            const taskActionItems = actionItems[task.id] || [];
            const openCount = taskActionItems.filter(item => !item.resolved).length;
            const bubbleHtml = openCount > 0 ? `<div class="notification-bubble">${openCount}</div>` : '';
            
            // Get working agents from local tracking OR backend fallback
            const workingAgents = workingAgentsByTask[task.id] 
                ? Array.from(workingAgentsByTask[task.id])
                : (task.working_agent ? [task.working_agent] : []);
            
            const aiWorkingHtml = workingAgents.length > 0 
                ? `<div class="ai-working" title="${workingAgents.join(', ')}">${workingAgents.map(agent => 
                    `<span class="ai-working-dot"></span><span class="ai-working-icon">${getAgentIcon(agent)}</span>`
                  ).join('')}</div>` 
                : '';
            
            return `
                <div class="card" 
                     draggable="true" 
                     ondragstart="handleDragStart(event, ${task.id})"
                     ondragend="handleDragEnd(event)"
                     ondragover="handleCardDragOver(event, ${task.id})"
                     ondrop="handleCardDrop(event, ${task.id}, '${task.status}')"
                     onclick="openEditTaskModal(${task.id})">
                    ${bubbleHtml}
                    ${aiWorkingHtml}
                    <div class="card-title">${escapeHtml(task.title)}</div>
                    <div class="card-meta">
                        <span class="tag priority-${task.priority}">${task.priority}</span>
                        <span class="tag agent-${task.agent.replace(/\s+/g, '-')}">${task.agent}</span>
                        ${task.due_date ? `<span class="tag">${task.due_date}</span>` : ''}
                    </div>
                </div>
            `;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Drag and Drop
        let draggedTaskId = null;
        
        function handleDragStart(event, taskId) {
            draggedTaskId = taskId;
            event.target.classList.add('dragging');
        }
        
        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            document.querySelectorAll('.column').forEach(c => c.classList.remove('drag-over'));
            document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-above'));
        }
        
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.closest('.column').classList.add('drag-over');
        }
        
        function handleCardDragOver(event, taskId) {
            event.preventDefault();
            event.stopPropagation();
            // Show visual indicator of drop position
            const card = event.currentTarget;
            const rect = card.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            
            // Clear all drag-above indicators
            document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-above', 'drag-below'));
            
            if (event.clientY < midY) {
                card.classList.add('drag-above');
            } else {
                card.classList.add('drag-below');
            }
            
            card.closest('.column').classList.add('drag-over');
        }
        
        async function handleDrop(event, newStatus) {
            event.preventDefault();
            document.querySelectorAll('.column').forEach(c => c.classList.remove('drag-over'));
            document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-above', 'drag-below'));
            
            if (!draggedTaskId) return;
            
            const draggedTask = tasks.find(t => t.id === draggedTaskId);
            const oldStatus = draggedTask?.status;
            
            // If dropping in same column, switch to custom sort
            if (oldStatus === newStatus) {
                columnSortMode[newStatus] = 'custom';
                // Build custom order from current DOM order
                const column = document.querySelector(`.column[data-status="${newStatus}"]`);
                const cardIds = Array.from(column.querySelectorAll('.card')).map(c => {
                    const onclick = c.getAttribute('onclick');
                    const match = onclick.match(/openEditTaskModal\((\d+)\)/);
                    return match ? parseInt(match[1]) : null;
                }).filter(id => id !== null);
                customSortOrder[newStatus] = cardIds;
                renderBoard();
            } else {
                // Moving to different column - use API
                await fetch(`${API}/api/tasks/${draggedTaskId}/move?status=${encodeURIComponent(newStatus)}&agent=User`, { method: 'POST' });
                await loadTasks();
                renderBoard();
            }
        }
        
        async function handleCardDrop(event, targetTaskId, newStatus) {
            event.preventDefault();
            event.stopPropagation();
            document.querySelectorAll('.column').forEach(c => c.classList.remove('drag-over'));
            document.querySelectorAll('.card').forEach(c => c.classList.remove('drag-above', 'drag-below'));
            
            if (!draggedTaskId || draggedTaskId === targetTaskId) return;
            
            const draggedTask = tasks.find(t => t.id === draggedTaskId);
            const oldStatus = draggedTask?.status;
            
            // Determine insert position (above or below target)
            const targetCard = event.currentTarget;
            const rect = targetCard.getBoundingClientRect();
            const insertBefore = event.clientY < (rect.top + rect.height / 2);
            
            if (oldStatus === newStatus) {
                // Reordering within same column - switch to custom
                columnSortMode[newStatus] = 'custom';
                
                // Get current visual order
                const column = document.querySelector(`.column[data-status="${newStatus}"]`);
                let cardIds = Array.from(column.querySelectorAll('.card')).map(c => {
                    const onclick = c.getAttribute('onclick');
                    const match = onclick.match(/openEditTaskModal\((\d+)\)/);
                    return match ? parseInt(match[1]) : null;
                }).filter(id => id !== null);
                
                // Remove dragged task from its current position
                cardIds = cardIds.filter(id => id !== draggedTaskId);
                
                // Find target position and insert
                const targetIdx = cardIds.indexOf(targetTaskId);
                if (insertBefore) {
                    cardIds.splice(targetIdx, 0, draggedTaskId);
                } else {
                    cardIds.splice(targetIdx + 1, 0, draggedTaskId);
                }
                
                customSortOrder[newStatus] = cardIds;
                renderBoard();
            } else {
                // Moving to different column via card drop
                await fetch(`${API}/api/tasks/${draggedTaskId}/move?status=${encodeURIComponent(newStatus)}&agent=User`, { method: 'POST' });
                await loadTasks();
                renderBoard();
            }
        }
        
        // Modal
        function openNewTaskModal() {
            // Clear everything explicitly - full blank slate
            document.getElementById('taskId').value = '';
            document.getElementById('taskTitleInput').value = '';
            document.getElementById('taskDescription').value = '';
            document.getElementById('taskStatus').value = 'Backlog';
            document.getElementById('taskPriority').value = 'Medium';
            document.getElementById('taskAgent').value = 'Unassigned';
            document.getElementById('taskDueDate').value = '';
            
            // Hide elements not relevant for new tasks
            document.getElementById('headerDeleteBtn').style.display = 'none';
            document.getElementById('theaterBtn').style.display = 'none';
            document.getElementById('chatSection').style.display = 'none';
            document.getElementById('sourceInfo').style.display = 'none';
            document.getElementById('actionItemsSection').style.display = 'none';
            document.getElementById('actionItemsList').innerHTML = '';
            document.getElementById('modalContainer').classList.add('new-task-mode');
            
            // Reset modal state
            document.getElementById('taskDetails').classList.remove('collapsed');
            detailsVisible = true;
            document.getElementById('toggleDetailsBtn').textContent = 'Hide Details';
            theaterMode = false;
            document.getElementById('modalContainer').classList.remove('theater-mode');
            
            // Clear any pasted images
            clearPastedImage();
            
            // Show modal
            document.getElementById('taskModal').classList.add('active');
        }
        
        async function openEditTaskModal(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            document.getElementById('taskId').value = task.id;
            document.getElementById('taskTitleInput').value = task.title;
            document.getElementById('taskDescription').value = task.description || '';
            document.getElementById('taskStatus').value = task.status;
            document.getElementById('taskPriority').value = task.priority;
            document.getElementById('taskAgent').value = task.agent;
            document.getElementById('taskDueDate').value = task.due_date || '';
            document.getElementById('headerDeleteBtn').style.display = '';
            document.getElementById('theaterBtn').style.display = '';
            document.getElementById('chatSection').style.display = 'block';
            document.getElementById('taskDetails').classList.remove('collapsed');
            document.getElementById('modalContainer').classList.remove('new-task-mode');
            detailsVisible = true;
            document.getElementById('toggleDetailsBtn').textContent = 'Hide Details';
            document.getElementById('taskModal').classList.add('active');
            
            // Show source info if available
            const sourceInfo = document.getElementById('sourceInfo');
            if (task.source_file && task.source_ref) {
                document.getElementById('sourceRefText').textContent = task.source_ref;
                sourceInfo.dataset.file = task.source_file;
                sourceInfo.style.display = 'block';
            } else {
                sourceInfo.style.display = 'none';
            }
            
            // Update stop button tooltip with agent name if known
            const stopAgentBtn = document.getElementById('stopAgentBtn');
            stopAgentBtn.title = task.working_agent ? `Stop ${task.working_agent}` : 'Stop agent';
            
            // Show working indicator if agent is currently working
            if (task.working_agent) {
                showChatWorkingIndicator(task.working_agent);
            } else {
                hideChatWorkingIndicator();
            }
            
            await loadAndRenderComments(taskId);
            await loadAndRenderActionItems(taskId);
            
            // Re-attach paste handler to ensure it works in modal context
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.removeEventListener('paste', handlePaste);
                chatInput.addEventListener('paste', handlePaste);
                console.log('Paste handler attached to chatInput');
            }
            
            // Clear any previous paste preview
            clearPastedImage();
        }
        
        function openSourceFile() {
            const sourceInfo = document.getElementById('sourceInfo');
            const file = sourceInfo.dataset.file;
            if (file) {
                navigator.clipboard.writeText(file).then(() => {
                    alert('Source file path copied to clipboard:\n' + file);
                });
            }
        }
        
        let replyingTo = []; // Track which messages we're replying to (array for multi-reply)
        
        async function loadAndRenderComments(taskId) {
            const taskComments = await fetch(`${API}/api/tasks/${taskId}/comments`).then(r => r.json());
            comments[taskId] = taskComments;
            
            const container = document.getElementById('chatMessages');
            
            if (taskComments.length === 0) {
                container.innerHTML = '<div class="empty-chat">No messages yet. Start the conversation!</div>';
            } else {
                container.innerHTML = taskComments.map((c, idx) => `
                    <div class="chat-message from-${c.agent.toLowerCase().replace(' ', '-')}" data-msg-id="${c.id}" data-msg-idx="${idx}">
                        <div class="export-checkbox-col">
                            <input type="checkbox" class="export-checkbox" data-msg-id="${c.id}">
                        </div>
                        <div class="chat-message-body">
                            <div class="chat-message-header">
                                <span class="agent">${escapeHtml(c.agent)}  -  <span class="time">${formatDateTime(c.created_at)}</span></span>
                                <span class="msg-actions">
                                    <button class="msg-action-btn msg-reply-btn" data-msg-id="${c.id}" data-agent="${escapeHtml(c.agent)}" title="Reply"></button>
                                    <button class="msg-action-btn msg-copy-btn" title="Copy"></button>
                                    <button class="msg-action-btn msg-delete-btn" data-msg-id="${c.id}" title="Delete" style="color: var(--danger, #dc3545);"></button>
                                </span>
                            </div>
                            <div class="chat-message-content">${formatMessageContent(c.content)}</div>
                        </div>
                    </div>
                `).join('');
                
                // If the last comment is from an agent (not User), hide the typing indicator
                const lastComment = taskComments[taskComments.length - 1];
                if (lastComment && lastComment.agent !== 'User') {
                    hideChatWorkingIndicator();
                }
            }
            
            container.scrollTop = container.scrollHeight;
        }
        
        let actionItemsCollapsed = false;
        let archiveViewVisible = false;
        
        async function loadAndRenderActionItems(taskId) {
            // Load open, resolved, and archived items
            const openItems = await fetch(`${API}/api/tasks/${taskId}/action-items`).then(r => r.json());
            const resolvedItems = await fetch(`${API}/api/tasks/${taskId}/action-items?resolved=true`).then(r => r.json());
            const archivedItems = await fetch(`${API}/api/tasks/${taskId}/action-items?archived=true`).then(r => r.json());
            const allActiveItems = [...openItems, ...resolvedItems];
            actionItems[taskId] = openItems; // Keep only open items for bubble count
            
            const section = document.getElementById('actionItemsSection');
            const list = document.getElementById('actionItemsList');
            const countEl = document.getElementById('actionItemsCount');
            const archiveViewer = document.getElementById('archiveViewer');
            const archivedList = document.getElementById('archivedItemsList');
            const archiveCount = document.getElementById('archiveCount');
            const archiveToggleBtn = document.getElementById('archiveToggleBtn');
            
            // Determine if section should show (has active or archived items)
            const hasItems = allActiveItems.length > 0 || archivedItems.length > 0;
            
            if (!hasItems) {
                section.style.display = 'none';
            } else {
                section.style.display = 'block';
                const openCount = openItems.length;
                countEl.textContent = openCount > 0 ? `${openCount} open` : (allActiveItems.length > 0 ? 'all done' : '');
                
                // Render active items (open + resolved)
                list.innerHTML = allActiveItems.map(item => `
                    <div class="action-item type-${item.item_type} ${item.resolved ? 'resolved' : ''}" onclick="quoteActionItem(${item.id}, '${escapeHtml(item.content).replace(/'/g, "\\'")}')">
                        <div class="action-item-check" onclick="event.stopPropagation(); ${item.resolved ? `unresolveActionItem(${item.id})` : `resolveActionItem(${item.id})`}" title="${item.resolved ? 'Click to unresolve' : 'Mark as resolved'}"></div>
                        <div style="flex: 1;">
                            <div class="action-item-content">${escapeHtml(item.content)}</div>
                            <div class="action-item-meta">
                                <span class="action-item-type ${item.item_type}">${item.item_type}</span>
                                 ${item.agent}  ${formatDateTime(item.created_at)}
                                ${item.resolved ? '   resolved' : ''}
                            </div>
                        </div>
                        <div class="action-item-actions">
                            ${item.resolved ? `<button class="action-item-archive" onclick="event.stopPropagation(); archiveActionItem(${item.id})" title="Archive"></button>` : ''}
                            <button class="action-item-delete" onclick="event.stopPropagation(); deleteActionItem(${item.id})" title="Delete"></button>
                        </div>
                    </div>
                `).join('');
                
                // Update archive toggle button
                if (archivedItems.length > 0) {
                    archiveToggleBtn.textContent = ` Archive (${archivedItems.length})`;
                    archiveToggleBtn.style.display = 'block';
                } else {
                    archiveToggleBtn.textContent = ' Archive';
                    archiveToggleBtn.style.display = allActiveItems.length > 0 ? 'block' : 'none';
                }
                
                // Render archived items
                if (archivedItems.length > 0) {
                    archiveCount.textContent = `${archivedItems.length} item${archivedItems.length !== 1 ? 's' : ''}`;
                    archivedList.innerHTML = archivedItems.map(item => `
                        <div class="action-item type-${item.item_type} resolved">
                            <div style="flex: 1;">
                                <div class="action-item-content">${escapeHtml(item.content)}</div>
                                <div class="action-item-meta">
                                    <span class="action-item-type ${item.item_type}">${item.item_type}</span>
                                     ${item.agent}  ${formatDateTime(item.created_at)}
                                </div>
                            </div>
                            <div class="action-item-actions" style="opacity: 1;">
                                <button class="action-item-unarchive" onclick="event.stopPropagation(); unarchiveActionItem(${item.id})" title="Restore"></button>
                                <button class="action-item-delete" onclick="event.stopPropagation(); deleteActionItem(${item.id})" title="Delete"></button>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Show/hide archive viewer based on state
                archiveViewer.style.display = archiveViewVisible && archivedItems.length > 0 ? 'block' : 'none';
            }
        }
        
        function toggleActionItemsCollapse() {
            actionItemsCollapsed = !actionItemsCollapsed;
            const section = document.getElementById('actionItemsSection');
            const content = document.getElementById('actionItemsContent');
            const btn = document.getElementById('actionItemsCollapseBtn');
            
            if (actionItemsCollapsed) {
                section.classList.add('collapsed');
                content.classList.add('collapsed');
                btn.textContent = '';
                btn.title = 'Expand';
            } else {
                section.classList.remove('collapsed');
                content.classList.remove('collapsed');
                btn.textContent = '';
                btn.title = 'Collapse';
            }
        }
        
        function toggleArchiveView() {
            archiveViewVisible = !archiveViewVisible;
            const archiveViewer = document.getElementById('archiveViewer');
            const archiveToggleBtn = document.getElementById('archiveToggleBtn');
            const archivedList = document.getElementById('archivedItemsList');
            
            if (archiveViewVisible && archivedList.innerHTML.trim()) {
                archiveViewer.style.display = 'block';
                archiveToggleBtn.classList.add('active');
            } else {
                archiveViewer.style.display = 'none';
                archiveToggleBtn.classList.remove('active');
            }
        }
        
        async function archiveActionItem(itemId) {
            await fetch(`${API}/api/action-items/${itemId}/archive`, { method: 'POST' });
            const taskId = parseInt(document.getElementById('taskId').value);
            await loadAndRenderActionItems(taskId);
            await loadTasks();
            renderBoard();
        }
        
        async function unarchiveActionItem(itemId) {
            await fetch(`${API}/api/action-items/${itemId}/unarchive`, { method: 'POST' });
            const taskId = parseInt(document.getElementById('taskId').value);
            await loadAndRenderActionItems(taskId);
            await loadTasks();
            renderBoard();
        }
        
        function quoteActionItem(itemId, content) {
            const chatInput = document.getElementById('chatInput');
            chatInput.value = `> Re: "${content.substring(0, 50)}${content.length > 50 ? '...' : ''}"\n\n`;
            chatInput.focus();
            chatInput.setSelectionRange(chatInput.value.length, chatInput.value.length);
        }
        
        async function resolveActionItem(itemId) {
            await fetch(`${API}/api/action-items/${itemId}/resolve`, { method: 'POST' });
            const taskId = parseInt(document.getElementById('taskId').value);
            await loadAndRenderActionItems(taskId);
            await loadTasks();
            renderBoard();
        }
        
        async function unresolveActionItem(itemId) {
            await fetch(`${API}/api/action-items/${itemId}/unresolve`, { method: 'POST' });
            const taskId = parseInt(document.getElementById('taskId').value);
            await loadAndRenderActionItems(taskId);
            await loadTasks();
            renderBoard();
        }
        
        async function deleteActionItem(itemId) {
            if (!confirm('Delete this action item?')) return;
            await fetch(`${API}/api/action-items/${itemId}`, { method: 'DELETE' });
            const taskId = parseInt(document.getElementById('taskId').value);
            await loadAndRenderActionItems(taskId);
            await loadTasks();
            renderBoard();
        }
        
        function formatMessageContent(content) {
            // Check if content is an image (base64 or URL)
            if (content.startsWith('data:image') || content.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
                return `<img src="${content}" alt="Attached image" class="chat-image-thumb" onclick="openImageViewer('${content}')">`;
            }
            
            // Check for image paths in format: /app/data/attachments/filename.ext
            // Convert to clickable thumbnails
            let processedContent = content;
            const imagePathRegex = /\s*\*\*Image attached:\*\*\s*`([^`]+)`[^\n]*(?:\n[^\n]*Read tool[^\n]*)?/g;
            processedContent = processedContent.replace(imagePathRegex, (match, path) => {
                // Convert /app/data/attachments/ to /data/attachments/ for browser access
                const browserPath = path.replace('/app/data/', '/data/');
                return `<img src="${browserPath}" alt="Attached image" class="chat-image-thumb" onclick="openImageViewer('${browserPath}')">`;
            });
            
            // Also handle legacy [IMAGE:...] format
            const imgMatch = processedContent.match(/\[IMAGE:(.*?)\]/);
            if (imgMatch) {
                const imgSrc = imgMatch[1];
                const text = processedContent.replace(/\[IMAGE:.*?\]/g, '').trim();
                const parsedText = text ? parseMarkdown(text) : '';
                return `${parsedText}${text ? '<br>' : ''}<img src="${imgSrc}" alt="Attached image" class="chat-image-thumb" onclick="openImageViewer('${imgSrc}')">`;
            }
            
            // Parse markdown
            return parseMarkdown(processedContent);
        }
        
        function openImageViewer(src) {
            // Create lightbox overlay
            const existing = document.getElementById('imageLightbox');
            if (existing) existing.remove();
            
            const lightbox = document.createElement('div');
            lightbox.id = 'imageLightbox';
            lightbox.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;cursor:pointer;';
            lightbox.onclick = () => lightbox.remove();
            
            const img = document.createElement('img');
            img.src = src;
            img.style.cssText = 'max-width:90%;max-height:90%;object-fit:contain;border-radius:8px;box-shadow:0 0 20px rgba(0,0,0,0.5);';
            img.onclick = (e) => e.stopPropagation();
            
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '';
            closeBtn.style.cssText = 'position:absolute;top:20px;right:20px;background:rgba(255,255,255,0.2);border:none;color:white;font-size:2rem;width:50px;height:50px;border-radius:50%;cursor:pointer;';
            closeBtn.onclick = () => lightbox.remove();
            
            lightbox.appendChild(img);
            lightbox.appendChild(closeBtn);
            document.body.appendChild(lightbox);
        }
        
        function parseMarkdown(content) {
            // Use marked.js if available, otherwise fallback to basic formatting
            if (typeof marked !== 'undefined') {
                // Configure marked for safe rendering
                marked.setOptions({
                    breaks: true,  // Convert \n to <br>
                    gfm: true,     // GitHub Flavored Markdown
                    sanitize: false // We'll handle sanitization
                });
                // Parse and return - marked handles escaping
                return marked.parse(content);
            }
            // Fallback: basic formatting if marked isn't loaded
            return escapeHtml(content)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }
        
        function closeModal() {
            document.getElementById('taskModal').classList.remove('active');
            document.getElementById('modalContainer').classList.remove('theater-mode');
            theaterMode = false;
            clearPastedImage();
        }
        
        function toggleTheaterMode() {
            theaterMode = !theaterMode;
            const modal = document.getElementById('modalContainer');
            const btn = document.getElementById('theaterBtn');
            const details = document.getElementById('taskDetails');
            const toggleBtn = document.getElementById('toggleDetailsBtn');
            
            if (theaterMode) {
                modal.classList.add('theater-mode');
                btn.textContent = '';
                btn.title = 'Exit Theater Mode';
                // Auto-hide details in theater mode
                details.classList.add('collapsed');
                detailsVisible = false;
                toggleBtn.textContent = 'Show Details';
            } else {
                modal.classList.remove('theater-mode');
                btn.textContent = '';
                btn.title = 'Enter Theater Mode';
                // Auto-show details when exiting theater mode
                details.classList.remove('collapsed');
                detailsVisible = true;
                toggleBtn.textContent = 'Hide Details';
            }
        }
        
        function toggleTaskDetails() {
            detailsVisible = !detailsVisible;
            const details = document.getElementById('taskDetails');
            const btn = document.getElementById('toggleDetailsBtn');
            
            if (detailsVisible) {
                details.classList.remove('collapsed');
                btn.textContent = 'Hide Details';
            } else {
                details.classList.add('collapsed');
                btn.textContent = 'Show Details';
            }
        }
        
        // Resize handle functionality
        function initResizeHandle() {
            const handle = document.getElementById('resizeHandle');
            const details = document.getElementById('taskDetails');
            const modalBody = details?.parentElement;
            
            if (!handle || !details || !modalBody) return;
            
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;
            
            handle.addEventListener('mousedown', (e) => {
                if (details.classList.contains('collapsed')) return;
                
                isResizing = true;
                startY = e.clientY;
                startHeight = details.offsetHeight;
                handle.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const newHeight = Math.max(100, Math.min(startHeight + deltaY, modalBody.offsetHeight - 250));
                details.style.maxHeight = newHeight + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    handle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        // Initialize resize handle when DOM is ready
        document.addEventListener('DOMContentLoaded', initResizeHandle);
        
        async function saveTask(event) {
            event.preventDefault();
            
            const saveBtn = document.getElementById('headerSaveBtn');
            const taskId = document.getElementById('taskId').value;
            const data = {
                title: document.getElementById('taskTitleInput').value,
                description: document.getElementById('taskDescription').value,
                status: document.getElementById('taskStatus').value,
                priority: document.getElementById('taskPriority').value,
                agent: document.getElementById('taskAgent').value,
                due_date: document.getElementById('taskDueDate').value || null,
            };
            
            // Show spinner
            saveBtn.classList.add('saving');
            saveBtn.classList.remove('saved');
            
            try {
                if (taskId) {
                    await fetch(`${API}/api/tasks/${taskId}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                } else {
                    await fetch(`${API}/api/tasks`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    closeModal();
                }
                
                await loadTasks();
                renderBoard();
                
                // Show success confirmation
                saveBtn.classList.remove('saving');
                saveBtn.classList.add('saved');
                
                // Reset after animation
                setTimeout(() => {
                    saveBtn.classList.remove('saved');
                }, 1500);
            } catch (error) {
                saveBtn.classList.remove('saving');
                console.error('Save failed:', error);
            }
        }
        
        // Delete confirmation modal
        function confirmDeleteTask() {
            const taskId = document.getElementById('taskId').value;
            if (!taskId) return; // Can't delete unsaved task
            
            const taskTitle = document.getElementById('taskTitleInput').value || 'this task';
            document.getElementById('deleteTaskName').textContent = `"${taskTitle}" will be permanently deleted.`;
            document.getElementById('deleteConfirmModal').classList.add('active');
        }
        
        function closeDeleteConfirm() {
            document.getElementById('deleteConfirmModal').classList.remove('active');
        }
        
        // ESC key to close delete confirmation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.getElementById('deleteConfirmModal').classList.contains('active')) {
                closeDeleteConfirm();
            }
        });
        
        async function executeDelete() {
            const taskId = document.getElementById('taskId').value;
            if (taskId) {
                await fetch(`${API}/api/tasks/${taskId}`, { method: 'DELETE' });
                closeDeleteConfirm();
                closeModal();
                await loadTasks();
                renderBoard();
            }
        }
        
        // Save from header button
        function saveTaskFromHeader() {
            document.getElementById('taskForm').requestSubmit();
        }
        
        async function deleteTask() {
            // Legacy function - now redirects to confirmation modal
            confirmDeleteTask();
        }
        
        // Chat
        async function sendChatMessage() {
            const taskId = document.getElementById('taskId').value;
            const input = document.getElementById('chatInput');
            let content = input.value.trim();
            
            if (!content && pastedImages.length === 0 && !attachedFile) return;
            
            // If there are pasted images, upload them first and get paths
            if (pastedImages.length > 0) {
                const imagePaths = [];
                for (let i = 0; i < pastedImages.length; i++) {
                    try {
                        const res = await fetch('/api/upload/image', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ data: pastedImages[i], filename: `image_${i + 1}` })
                        });
                        if (res.ok) {
                            const result = await res.json();
                            imagePaths.push(result.path);
                        }
                    } catch (e) {
                        console.error('Failed to upload image:', e);
                    }
                }
                if (imagePaths.length > 0) {
                    const imageMarkup = imagePaths.map(path => ` **Image attached:** \`${path}\`\nUse the Read tool to view this image.`).join('\n\n');
                    content = content ? `${content}\n\n${imageMarkup}` : imageMarkup;
                }
            }
            
            // If there's an attached file, include it as a code block
            if (attachedFile) {
                const fileHeader = `\n\n** Attached file: ${attachedFile.name}**\n`;
                const fileContent = '```\n' + attachedFile.content + '\n```';
                content = content ? `${content}${fileHeader}${fileContent}` : `${fileHeader}${fileContent}`;
            }
            
            // If replying to messages, prepend the quotes
            if (replyingTo.length > 0) {
                const quoteBlock = replyingTo.map(r => 
                    `> ** Reply to ${r.agent}:** ${r.preview}`
                ).join('\n') + '\n\n';
                content = quoteBlock + content;
            }
            
            // Get the assigned agent for this task
            const task = tasks.find(t => t.id == taskId);
            const assignedAgent = task ? task.agent : 'Agent';
            
            // Show typing indicator optimistically (agent is about to think)
            showChatWorkingIndicator(assignedAgent);
            
            // Also trigger the card working animation via API (optimistic)
            if (task && task.agent && task.agent !== 'User' && task.agent !== 'Unassigned') {
                fetch(`${API}/api/tasks/${taskId}/start-work?agent=${encodeURIComponent(task.agent)}`, { method: 'POST' })
                    .catch(() => {}); // Ignore errors, this is optimistic
            }
            
            await fetch(`${API}/api/tasks/${taskId}/comments`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ agent: 'User', content })
            });
            
            resetChatInput();
            clearPastedImage();
            await loadAndRenderComments(taskId);
        }
        
        let chatWorkingPollInterval = null;
        let chatWorkingAgents = new Set(); // Track multiple working agents
        
        function showChatWorkingIndicator(agentName) {
            if (!agentName) return;
            
            chatWorkingAgents.add(agentName);
            updateChatWorkingIndicatorUI();
            
            // Start polling as fallback in case WebSocket event is missed
            clearInterval(chatWorkingPollInterval);
            const taskId = document.getElementById('taskId')?.value;
            if (taskId) {
                chatWorkingPollInterval = setInterval(async () => {
                    try {
                        const taskComments = await fetch(`${API}/api/tasks/${taskId}/comments`).then(r => r.json());
                        const lastComment = taskComments[taskComments.length - 1];
                        if (lastComment && lastComment.agent !== 'User') {
                            // Agent has responded, hide their indicator
                            removeChatWorkingAgent(lastComment.agent);
                        }
                    } catch (e) {
                        // Ignore poll errors
                    }
                }, 3000); // Poll every 3 seconds as fallback
            }
        }
        
        function removeChatWorkingAgent(agentName) {
            chatWorkingAgents.delete(agentName);
            updateChatWorkingIndicatorUI();
            
            // Stop polling if no agents working
            if (chatWorkingAgents.size === 0) {
                clearInterval(chatWorkingPollInterval);
                chatWorkingPollInterval = null;
            }
        }
        
        function updateChatWorkingIndicatorUI() {
            const indicator = document.getElementById('chatWorkingIndicator');
            const agentsContainer = document.getElementById('chatWorkingAgents');
            
            if (!indicator || !agentsContainer) return;
            
            if (chatWorkingAgents.size === 0) {
                indicator.style.display = 'none';
                agentsContainer.innerHTML = '';
                indicator.title = '';
                return;
            }
            
            // Build agent icons with dots
            const agentArray = Array.from(chatWorkingAgents);
            agentsContainer.innerHTML = agentArray.map(agent => 
                `<div class="chat-working-agent" title="${agent}">
                    <span class="ai-working-dot"></span>
                    <span class="ai-working-icon">${getAgentIcon(agent)}</span>
                </div>`
            ).join('');
            
            // Set tooltip only (no visible text) - matches card indicator format
            indicator.title = agentArray.join(', ');
            
            indicator.style.display = 'flex';
        }
        
        function hideChatWorkingIndicator() {
            chatWorkingAgents.clear();
            updateChatWorkingIndicatorUI();
            // Stop fallback polling
            clearInterval(chatWorkingPollInterval);
            chatWorkingPollInterval = null;
        }
        
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }
        
        function autoGrowChatInput(el) {
            el.style.height = 'auto';
            const isTheater = document.getElementById('modalContainer')?.classList.contains('theater-mode');
            const maxHeight = isTheater ? 200 : 150;
            el.style.height = Math.min(el.scrollHeight, maxHeight) + 'px';
        }
        
        function resetChatInput() {
            const input = document.getElementById('chatInput');
            if (input) {
                input.value = '';
                input.style.height = '44px';
            }
            clearReplyPreview();
        }
        
        // Reply to a specific message (supports multiple)
        function replyToMessage(msgId, agent, preview) {
            // Check if already replying to this message
            const existing = replyingTo.find(r => r.id === msgId);
            if (existing) return; // Already added
            
            replyingTo.push({ id: msgId, agent: agent, preview: preview });
            updateReplyPreview();
            
            // Focus the input
            document.getElementById('chatInput')?.focus();
        }
        
        function removeReply(msgId) {
            replyingTo = replyingTo.filter(r => r.id !== msgId);
            updateReplyPreview();
        }
        
        function clearReplyPreview() {
            replyingTo = [];
            updateReplyPreview();
        }
        
        function updateReplyPreview() {
            const inputArea = document.querySelector('.chat-input-area');
            if (!inputArea) {
                console.warn('chat-input-area not found');
                return;
            }
            
            let replyPreview = inputArea.querySelector('.reply-preview-container');
            
            if (replyingTo.length === 0) {
                if (replyPreview) replyPreview.remove();
                return;
            }
            
            if (!replyPreview) {
                replyPreview = document.createElement('div');
                replyPreview.className = 'reply-preview-container';
                inputArea.insertBefore(replyPreview, inputArea.firstChild);
            }
            
            replyPreview.innerHTML = replyingTo.map(r => `
                <div class="reply-preview">
                    <span class="reply-preview-text"> <strong>${r.agent}</strong>: ${r.preview}</span>
                    <button class="reply-preview-close" onclick="removeReply(${r.id})"></button>
                </div>
            `).join('') + (replyingTo.length > 0 ? `<button class="reply-clear-all" onclick="clearReplyPreview()">Clear all</button>` : '');
        }
        
        // Copy message content to clipboard
        function copyMessageContent(msgEl) {
            const content = msgEl.querySelector('.chat-message-content')?.innerText || '';
            if (!content) {
                console.warn('No content to copy');
                return;
            }
            
            // Modern clipboard API with fallback
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(content).then(() => {
                    showCopyFeedback(msgEl.querySelector('.msg-copy-btn'));
                }).catch(err => {
                    console.error('Clipboard write failed:', err);
                    fallbackCopy(content, msgEl.querySelector('.msg-copy-btn'));
                });
            } else {
                fallbackCopy(content, msgEl.querySelector('.msg-copy-btn'));
            }
        }
        
        // Fallback copy for non-secure contexts
        function fallbackCopy(text, btn) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.cssText = 'position:fixed;left:-9999px;top:-9999px;';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback(btn);
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Copy failed. Try selecting the text manually.');
            }
            document.body.removeChild(textarea);
        }
        
        // Show visual feedback on copy button
        function showCopyFeedback(btn) {
            if (btn) {
                const original = btn.innerHTML;
                btn.innerHTML = '';
                btn.style.color = 'var(--low, #22c55e)';
                setTimeout(() => {
                    btn.innerHTML = original;
                    btn.style.color = '';
                }, 1000);
            }
        }
        
        // Delete message from chat
        async function deleteMessage(msgId, msgEl) {
            const taskId = document.getElementById('taskId')?.value;
            if (!taskId || !msgId) {
                console.error('Delete failed: missing taskId or msgId', { taskId, msgId });
                return;
            }
            if (!confirm('Delete this message? This cannot be undone.')) return;
            
            try {
                const resp = await fetch(`/api/tasks/${taskId}/comments/${msgId}`, {
                    method: 'DELETE'
                });
                if (resp.ok) {
                    msgEl.remove();
                } else {
                    const errData = await resp.text();
                    console.error('Delete failed:', resp.status, errData);
                    alert('Failed to delete message');
                }
            } catch (err) {
                console.error('Delete message error:', err);
                alert('Failed to delete message');
            }
        }
        
        // Event delegation for chat message action buttons (on document for reliability)
        document.addEventListener('click', function(e) {
            // Only handle clicks inside chat-messages container
            const msgEl = e.target.closest('.chat-message');
            if (!msgEl || !msgEl.closest('#chatMessages')) return;
            
            // Reply button
            if (e.target.closest('.msg-reply-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const btn = e.target.closest('.msg-reply-btn');
                const msgId = btn.dataset.msgId;
                const agent = btn.dataset.agent;
                const content = msgEl.querySelector('.chat-message-content')?.innerText || '';
                const preview = content.substring(0, 100) + (content.length > 100 ? '...' : '');
                replyToMessage(parseInt(msgId), agent, preview);
                return;
            }
            
            // Copy button
            if (e.target.closest('.msg-copy-btn')) {
                e.preventDefault();
                e.stopPropagation();
                copyMessageContent(msgEl);
                return;
            }
            
            // Delete button
            if (e.target.closest('.msg-delete-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const btn = e.target.closest('.msg-delete-btn');
                const msgId = btn.dataset.msgId;
                deleteMessage(parseInt(msgId), msgEl);
                return;
            }
        });
        
        // Export mode state
        let exportMode = false;
        
        function toggleExportMode() {
            exportMode = !exportMode;
            const chatMessages = document.getElementById('chatMessages');
            
            if (exportMode) {
                chatMessages.classList.add('export-mode');
                
                // Add export controls bar
                let exportControls = document.getElementById('exportControls');
                if (!exportControls) {
                    exportControls = document.createElement('div');
                    exportControls.id = 'exportControls';
                    exportControls.style.cssText = 'display:flex;gap:0.5rem;padding:0.5rem;background:var(--bg-column);border-bottom:1px solid var(--border);';
                    exportControls.innerHTML = `
                        <button class="btn btn-secondary" onclick="selectAllMessages(true)">Select All</button>
                        <button class="btn btn-secondary" onclick="selectAllMessages(false)">Deselect All</button>
                        <button class="btn" onclick="exportSelectedMessages()">Download .MD</button>
                        <button class="btn btn-secondary" onclick="toggleExportMode()">Cancel</button>
                    `;
                    const chatSection = document.getElementById('chatSection');
                    chatSection.insertBefore(exportControls, chatMessages);
                }
            } else {
                chatMessages.classList.remove('export-mode');
                const exportControls = document.getElementById('exportControls');
                if (exportControls) exportControls.remove();
                document.querySelectorAll('.export-checkbox').forEach(cb => cb.checked = false);
            }
        }
        
        function selectAllMessages(select) {
            document.querySelectorAll('.export-checkbox').forEach(cb => cb.checked = select);
        }
        
        function exportSelectedMessages() {
            const taskId = document.getElementById('taskId').value;
            const task = tasks.find(t => t.id == taskId);
            const taskComments = comments[taskId] || [];
            
            const selectedIds = Array.from(document.querySelectorAll('.export-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.msgId));
            
            if (selectedIds.length === 0) {
                alert('Please select at least one message to export.');
                return;
            }
            
            const selectedMessages = taskComments.filter(c => selectedIds.includes(c.id));
            
            // Build markdown content
            let md = `# ${task?.title || 'Chat Export'}\n\n`;
            md += `**Exported:** ${new Date().toLocaleString()}\n\n---\n\n`;
            
            selectedMessages.forEach(msg => {
                md += `### ${msg.agent}  ${formatDateTime(msg.created_at)}\n\n`;
                md += `${msg.content}\n\n---\n\n`;
            });
            
            // Trigger download
            const blob = new Blob([md], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-export-${taskId}-${Date.now()}.md`;
            a.click();
            URL.revokeObjectURL(url);
            
            toggleExportMode();
        }
        
        // Paste handler for images
        function setupPasteHandler() {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('paste', handlePaste);
            } else {
                console.warn('chatInput not found for paste handler');
            }
        }
        
        function handlePaste(event) {
            console.log('Paste event triggered', event);
            const items = event.clipboardData?.items;
            if (!items) {
                console.log('No clipboard items');
                return;
            }
            
            console.log('Clipboard items:', items.length);
            for (const item of items) {
                console.log('Item type:', item.type);
                if (item.type.startsWith('image/')) {
                    event.preventDefault();
                    const file = item.getAsFile();
                    console.log('Got image file:', file);
                    if (file) {
                        processImageFile(file);
                    }
                    break;
                }
            }
        }
        
        let attachedFile = null;  // Store file info for non-image files
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type.startsWith('image/')) {
                processImageFile(file);
            } else {
                // Handle non-image files (text, json, etc.)
                processTextFile(file);
            }
        }
        
        function processImageFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                pastedImages.push(e.target.result);
                attachedFile = null;
                renderPastePreview();
            };
            reader.readAsDataURL(file);
        }
        
        function renderPastePreview() {
            const previewContainer = document.getElementById('pastePreview');
            if (!previewContainer) return;
            
            if (pastedImages.length === 0) {
                previewContainer.classList.remove('active');
                previewContainer.innerHTML = '';
                return;
            }
            
            previewContainer.innerHTML = pastedImages.map((img, idx) => `
                <div class="paste-preview-item" style="position: relative; display: inline-block;">
                    <img src="${img}" alt="Pasted image ${idx + 1}">
                    <button class="remove-btn" onclick="removePastedImage(${idx})" title="Remove"></button>
                </div>
            `).join('');
            previewContainer.classList.add('active');
        }
        
        function removePastedImage(index) {
            pastedImages.splice(index, 1);
            renderPastePreview();
        }
        
        function processTextFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                attachedFile = {
                    name: file.name,
                    type: file.type,
                    content: e.target.result
                };
                pastedImageData = null;
                document.getElementById('pastePreviewImg').style.display = 'none';
                let fileNameEl = document.getElementById('filePreviewName');
                if (!fileNameEl) {
                    // Create file name preview element if it doesn't exist
                    fileNameEl = document.createElement('div');
                    fileNameEl.id = 'filePreviewName';
                    fileNameEl.style.cssText = 'padding: 0.5rem; background: var(--bg-dark); border-radius: 4px; font-size: 0.85rem;';
                    document.getElementById('pastePreview').insertBefore(fileNameEl, document.getElementById('pastePreviewImg'));
                }
                fileNameEl.textContent = ` ${file.name}`;
                fileNameEl.style.display = 'block';
                document.getElementById('pastePreview').classList.add('active');
            };
            reader.readAsText(file);
        }
        
        function clearPastedImage() {
            pastedImages = [];
            attachedFile = null;
            renderPastePreview();
            document.getElementById('fileInput').value = '';
        }
        
        // Filter change
        document.getElementById('filterAgent').addEventListener('change', async () => {
            await loadTasks();
            renderBoard();
        });
        
        // WebSocket for live updates
        let ws = null;
        let wsConnected = false;
        let wsReconnecting = false;
        let wsReconnectAttempts = 0;
        const WS_MAX_RECONNECT_ATTEMPTS = 5;
        
        function showReconnectingIndicator() {
            wsReconnecting = true;
            // Show in collapsed preview
            const preview = document.getElementById('commandBarPreview');
            if (preview && !commandBarExpanded) {
                preview.dataset.originalText = preview.textContent;
                preview.textContent = ' Reconnecting...';
                preview.style.opacity = '0.7';
            }
            // Also show glowing shield in expanded header (reuse thinking indicator)
            const thinking = document.getElementById('jarvisThinking');
            const thinkingCollapsed = document.getElementById('jarvisThinkingCollapsed');
            if (thinking) {
                thinking.style.display = 'inline';
                thinking.title = 'Reconnecting...';
            }
            if (thinkingCollapsed) {
                thinkingCollapsed.style.display = 'inline-flex';
                thinkingCollapsed.title = 'Reconnecting...';
            }
        }
        
        function hideReconnectingIndicator() {
            wsReconnecting = false;
            wsReconnectAttempts = 0;
            const preview = document.getElementById('commandBarPreview');
            if (preview && preview.dataset.originalText) {
                preview.textContent = preview.dataset.originalText;
                preview.style.opacity = '1';
                delete preview.dataset.originalText;
            }
            // Hide the glowing shield (unless jarvisLoading is true)
            const thinking = document.getElementById('jarvisThinking');
            const thinkingCollapsed = document.getElementById('jarvisThinkingCollapsed');
            if (thinking && !jarvisLoading) {
                thinking.style.display = 'none';
                thinking.title = '';
            }
            if (thinkingCollapsed && !jarvisLoading) {
                thinkingCollapsed.style.display = 'none';
                thinkingCollapsed.title = '';
            }
        }
        
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            
            ws.onopen = () => {
                console.log('Live updates connected');
                wsConnected = true;
                hideReconnectingIndicator();
                setInterval(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send('ping');
                    }
                }, 30000);
            };
            
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                console.log('Live update:', data.type);
                
                if (data.type === 'task_created' || data.type === 'task_updated' || data.type === 'task_deleted') {
                    await loadTasks();
                    renderBoard();
                }
                
                if (data.type === 'comment_added') {
                    const openTaskId = document.getElementById('taskId').value;
                    if (openTaskId && parseInt(openTaskId) === data.task_id) {
                        await loadAndRenderComments(data.task_id);
                        // Always hide typing indicator when any comment arrives (agent responded)
                        // Check both the comment object and just hide if it's not from User
                        const agent = data.comment?.agent || '';
                        if (agent !== 'User') {
                            hideChatWorkingIndicator();
                        }
                    }
                }
                
                if (data.type === 'comment_deleted') {
                    const openTaskId = document.getElementById('taskId').value;
                    if (openTaskId && parseInt(openTaskId) === data.task_id) {
                        // Remove the message element directly
                        const msgEl = document.querySelector(`.chat-message[data-msg-id="${data.comment_id}"]`);
                        if (msgEl) msgEl.remove();
                    }
                }
                
                if (data.type === 'action_item_added' || data.type === 'action_item_resolved' || data.type === 'action_item_deleted') {
                    const openTaskId = document.getElementById('taskId').value;
                    if (openTaskId && parseInt(openTaskId) === data.task_id) {
                        await loadAndRenderActionItems(data.task_id);
                    }
                    // Refresh board to update notification bubbles
                    await loadTasks();
                    renderBoard();
                }
                
                if (data.type === 'work_started') {
                    // Track working agent for this task (supports multiple)
                    if (data.task_id && data.agent) {
                        if (!workingAgentsByTask[data.task_id]) {
                            workingAgentsByTask[data.task_id] = new Set();
                        }
                        workingAgentsByTask[data.task_id].add(data.agent);
                    }
                    // Refresh board to show AI working indicator on card
                    await loadTasks();
                    renderBoard();
                    // Also show in modal if this task is open
                    const openTaskId = document.getElementById('taskId').value;
                    if (openTaskId && parseInt(openTaskId) === data.task_id && data.agent) {
                        showChatWorkingIndicator(data.agent);
                    }
                }
                
                if (data.type === 'work_stopped') {
                    // Remove agent from tracking (supports multiple)
                    if (data.task_id && data.agent && workingAgentsByTask[data.task_id]) {
                        workingAgentsByTask[data.task_id].delete(data.agent);
                        if (workingAgentsByTask[data.task_id].size === 0) {
                            delete workingAgentsByTask[data.task_id];
                        }
                    }
                    // Refresh board to update AI working indicator on card
                    await loadTasks();
                    renderBoard();
                    // Also remove specific agent from modal indicator if this task is open
                    const openTaskId = document.getElementById('taskId').value;
                    if (openTaskId && parseInt(openTaskId) === data.task_id && data.agent) {
                        removeChatWorkingAgent(data.agent);
                    }
                }
                
                if (data.type === 'session_deleted') {
                    // Remove deleted session from local state immediately
                    const deletedKey = data.session_key;
                    activeSessions = activeSessions.filter(s => s.key !== deletedKey);
                    delete jarvisHistoryBySession[deletedKey];
                    
                    // If we're viewing the deleted session, switch to main
                    if (currentSessionKey === deletedKey) {
                        currentSessionKey = 'main';
                        jarvisChatHistory = jarvisHistoryBySession['main'] || [];
                        renderJarvisChat();
                    }
                    
                    updateSessionSelector();
                    updateDeleteButtonVisibility();
                    console.log('Session deleted via WebSocket:', deletedKey);
                }
                
                if (data.type === 'command_bar_message') {
                    // Proactive Jarvis message via WebSocket
                    handleJarvisWebSocketMessage(data.message);
                }
            };
            
            ws.onclose = () => {
                wsConnected = false;
                wsReconnectAttempts++;
                console.log(`WebSocket closed, attempt ${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS}, reconnecting in 2s...`);
                showReconnectingIndicator();
                setTimeout(connectWebSocket, 2000);
            };
            
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                wsConnected = false;
                ws.close();
            };
        }
        
        // Command Bar - Jarvis Chat (via Backend API)
        let commandBarExpanded = false;
        let commandFullsize = false;
        let jarvisChatHistory = [];
        let jarvisHistoryBySession = {}; // session_key -> messages[]
        let lastJarvisMessage = 'Ask anything...';  // Updated by applyBranding()
        let jarvisLoading = false;
        let commandAttachments = []; // {type, data, filename}
        let activeSessions = [];
        let currentSessionKey = 'main';
        
        // Load chat history from backend for a specific session
        async function loadJarvisHistory(sessionKey = null) {
            const session = sessionKey || currentSessionKey;
            try {
                const res = await fetch(`/api/jarvis/history?session=${encodeURIComponent(session)}`);
                if (res.ok) {
                    const data = await res.json();
                    const messages = (data.history || []).map(msg => ({
                        id: msg.id,
                        session_key: msg.session_key,
                        role: msg.role,
                        content: msg.content,
                        attachments: msg.attachments || null,
                        time: msg.timestamp ? formatTime(msg.timestamp) : ''
                    }));
                    
                    // Cache history per session
                    jarvisHistoryBySession[session] = messages;
                    
                    // If this is the current session, update display
                    if (session === currentSessionKey) {
                        jarvisChatHistory = messages;
                        renderJarvisChat();
                        // Update preview from last assistant message
                        const lastAssistant = [...jarvisChatHistory].reverse().find(m => m.role === 'assistant');
                        if (lastAssistant) {
                            lastJarvisMessage = lastAssistant.content.length > 60 
                                ? lastAssistant.content.substring(0, 60) + '...' 
                                : lastAssistant.content;
                            updateCommandBarPreview();
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to load Jarvis history:', e);
            }
        }
        
        // Load available sessions from OpenClaw
        async function loadSessions() {
            try {
                const res = await fetch('/api/sessions');
                if (res.ok) {
                    const data = await res.json();
                    activeSessions = data.sessions || [];
                    updateSessionSelector();
                }
            } catch (e) {
                console.error('Failed to load sessions:', e);
            }
        }
        
        function updateSessionSelector() {
            const selector = document.getElementById('sessionSelector');
            if (!selector) return;
            
            const currentValue = selector.value;
            
            // Build options from API response (main session comes from API too)
            let options = '';
            for (const session of activeSessions) {
                options += `<option value="${escapeHtml(session.key)}">${escapeHtml(session.label)}</option>`;
            }
            
            // Fallback if no sessions (shouldn't happen)
            if (!options) {
                options = '<option value="main">Jarvis (Main)</option>';
            }
            
            selector.innerHTML = options;
            
            // Restore selection if still valid
            if ([...selector.options].some(o => o.value === currentValue)) {
                selector.value = currentValue;
            } else {
                // Default to first option (should be main)
                selector.value = selector.options[0]?.value || 'main';
                currentSessionKey = selector.value;
            }
        }
        
        async function switchSession(sessionKey) {
            currentSessionKey = sessionKey;
            updateDeleteButtonVisibility();
            
            // Check if we have cached history for this session
            if (jarvisHistoryBySession[sessionKey]) {
                jarvisChatHistory = jarvisHistoryBySession[sessionKey];
                renderJarvisChat();
            } else {
                // Load from server
                jarvisChatHistory = [];
                renderJarvisChat();
                await loadJarvisHistory(sessionKey);
            }
        }
        
        async function refreshSessions() {
            await loadSessions();
        }
        
        // Create new session - prompts for name first
        async function createNewSession() {
            // Generate default name with timestamp
            const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            const defaultLabel = `Session ${timestamp}`;
            
            // Prompt for session name using custom modal
            showRenameModal(defaultLabel, async (label) => {
                if (!label || !label.trim()) {
                    return; // Cancelled
                }
                
                const btn = document.querySelector('.new-session-btn');
                if (btn) {
                    btn.disabled = true;
                    btn.textContent = '...';
                }
                
                try {
                    const res = await fetch('/api/sessions/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            label: label.trim(),
                            agentId: 'main',
                            task: 'New session created from Task Board. Ready for instructions.'
                        })
                    });
                    
                    const data = await res.json();
                    if (data.success) {
                        // Refresh sessions to show new one
                        await loadSessions();
                        // Switch to the new session - key is in result.details.childSessionKey
                        const newKey = data.result?.details?.childSessionKey || data.result?.childSessionKey;
                        if (newKey) {
                            currentSessionKey = newKey;
                            document.getElementById('sessionSelector').value = newKey;
                            updateDeleteButtonVisibility();
                            await loadJarvisHistory(newKey);
                        }
                    } else {
                        showConfirmModal('? Error', 'Failed to create session: ' + (data.error || 'Unknown error'), 'OK', () => {});
                    }
                } catch (e) {
                    console.error('Error creating session:', e);
                    showConfirmModal('? Error', 'Failed to create session: ' + e.message, 'OK', () => {});
                } finally {
                    const btn = document.querySelector('.new-session-btn');
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = '+ New';
                    }
                }
            });
        }
        
        // Delete/close current session
        function deleteCurrentSession() {
            if (isMainSession(currentSessionKey)) {
                alert('Cannot delete the main session');
                return;
            }
            
            // Get session label for display
            const selector = document.getElementById('sessionSelector');
            const selectedOption = selector.options[selector.selectedIndex];
            const sessionLabel = selectedOption ? selectedOption.text : currentSessionKey;
            
            showConfirmModal(
                'Close Session',
                `Close "${sessionLabel}"? This will stop the session and clear its chat history.`,
                'Close Session',
                async () => {
                    const btn = document.getElementById('deleteSessionBtn');
                    btn.disabled = true;
                    
                    try {
                        const res = await fetch(`/api/sessions/${encodeURIComponent(currentSessionKey)}`, {
                            method: 'DELETE'
                        });
                        const data = await res.json();
                        
                        if (data.success) {
                            // Visual feedback
                            btn.style.background = 'var(--low)';
                            btn.style.borderColor = 'var(--low)';
                            
                            // Clear cached history for this session
                            delete jarvisHistoryBySession[currentSessionKey];
                            
                            // Switch back to first available session
                            await loadSessions();
                            
                            // Update selector to first option (main)
                            const selector = document.getElementById('sessionSelector');
                            if (selector.options.length > 0) {
                                currentSessionKey = selector.options[0].value;
                                selector.value = currentSessionKey;
                            }
                            
                            updateDeleteButtonVisibility();
                            await loadJarvisHistory(currentSessionKey);
                            
                            setTimeout(() => {
                                btn.style.background = '';
                                btn.style.borderColor = '';
                            }, 1000);
                        } else {
                            alert('Failed to delete session: ' + (data.error || 'Unknown error'));
                        }
                    } catch (e) {
                        console.error('Error deleting session:', e);
                        alert('Error deleting session: ' + e.message);
                    } finally {
                        btn.disabled = false;
                    }
                }
            );
        }
        
        // Custom input modal for naming sessions
        let renameCallback = null;
        
        function showRenameModal(currentValue, callback, title = '? New Session', buttonText = 'Create') {
            renameCallback = callback;
            document.getElementById('renameModalTitle').textContent = title;
            document.getElementById('renameModalBtn').textContent = buttonText;
            document.getElementById('renameInput').value = currentValue;
            document.getElementById('renameModal').classList.add('active');
            document.getElementById('renameInput').focus();
            document.getElementById('renameInput').select();
        }
        
        function closeRenameModal() {
            document.getElementById('renameModal').classList.remove('active');
            renameCallback = null;
        }
        
        function executeRename() {
            const newValue = document.getElementById('renameInput').value;
            if (renameCallback) {
                renameCallback(newValue);
            }
            closeRenameModal();
        }
        
        // Stop current session
        async function stopCurrentSession() {
            const btn = document.getElementById('stopSessionBtn');
            btn.disabled = true;
            
            try {
                await fetch(`/api/sessions/${encodeURIComponent(currentSessionKey)}/stop`, {
                    method: 'POST'
                });
                
                // Visual feedback - green for success
                btn.style.background = 'var(--low)';
                btn.style.borderColor = 'var(--low)';
                btn.style.color = 'white';
                
                setTimeout(() => {
                    btn.disabled = false;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
            } catch (e) {
                console.error('Error stopping session:', e);
                btn.disabled = false;
            }
        }
        
        // Emergency stop all agents
        async function stopAllAgents() {
            if (!confirm('STOP: This will attempt to stop ALL running agent sessions. Continue?')) {
                return;
            }
            
            const btn = document.getElementById('stopAllBtn');
            btn.disabled = true;
            
            try {
                const res = await fetch('/api/sessions/stop-all', { method: 'POST' });
                const data = await res.json();
                
                // Visual feedback - green for success
                btn.style.background = 'var(--low)';
                btn.style.borderColor = 'var(--low)';
                btn.style.color = 'white';
                btn.title = `Stopped ${data.stopped?.length || 0} sessions`;
                
                setTimeout(() => {
                    btn.disabled = false;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                    btn.title = 'Stop all agents';
                }, 3000);
                
                // Refresh sessions
                await loadSessions();
            } catch (e) {
                console.error('Error stopping all:', e);
                btn.disabled = false;
            }
        }
        
        // Stop agent working on a task
        async function stopTaskAgent() {
            const taskId = document.getElementById('taskId').value;
            if (!taskId) return;
            
            const btn = document.getElementById('stopAgentBtn');
            btn.disabled = true;
            
            try {
                // Get the task's session key
                const task = tasks.find(t => t.id == taskId);
                if (task && task.agent_session_key) {
                    await fetch(`/api/sessions/${encodeURIComponent(task.agent_session_key)}/stop`, {
                        method: 'POST'
                    });
                }
                
                // Also stop the work indicator
                await fetch(`/api/tasks/${taskId}/stop-work`, { method: 'POST' });
                
                // Hide chat working indicator
                hideChatWorkingIndicator();
                
                // Visual feedback
                btn.style.background = 'var(--low)';
                btn.style.borderColor = 'var(--low)';
                btn.style.color = 'white';
                
                setTimeout(() => {
                    btn.disabled = false;
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    btn.style.color = '';
                }, 2000);
                
                // Refresh board
                await loadTasks();
                renderBoard();
            } catch (e) {
                console.error('Error stopping agent:', e);
                btn.disabled = false;
            }
        }
        
        // Check if session key is the main session
        function isMainSession(key) {
            return key === 'main' || key === 'agent:main:main' || key?.includes('agent:main:main');
        }
        
        // Confirmation modal
        let confirmCallback = null;
        
        function showConfirmModal(title, message, buttonText, callback) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmBtn').textContent = buttonText;
            confirmCallback = callback;
            document.getElementById('confirmModal').classList.add('active');
        }
        
        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('active');
            confirmCallback = null;
        }
        
        function executeConfirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            closeConfirmModal();
        }
        
        // Update edit/delete buttons - disable for main session but keep visible
        function updateDeleteButtonVisibility() {
            const deleteBtn = document.getElementById('deleteSessionBtn');
            const isMain = isMainSession(currentSessionKey);
            
            if (deleteBtn) {
                deleteBtn.disabled = isMain;
                deleteBtn.style.opacity = isMain ? '0.3' : '1';
                deleteBtn.title = isMain ? 'Cannot delete main session' : 'Close this session';
            }
        }
        
        // Command bar paste handler
        function setupCommandPasteHandler() {
            const input = document.getElementById('jarvisChatInput');
            if (input) {
                input.addEventListener('paste', handleCommandPaste);
            }
        }
        
        function handleCommandPaste(event) {
            const items = event.clipboardData?.items;
            if (!items) return;
            
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    event.preventDefault();
                    const file = item.getAsFile();
                    processCommandFile(file);
                    break;
                }
            }
        }
        
        function handleCommandFileSelect(event) {
            const files = event.target.files;
            for (const file of files) {
                processCommandFile(file);
            }
            event.target.value = ''; // Reset so same file can be selected again
        }
        
        function processCommandFile(file) {
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                alert(`File ${file.name} is too large (max 10MB)`);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const attachment = {
                    type: file.type,
                    data: e.target.result,
                    filename: file.name
                };
                commandAttachments.push(attachment);
                renderCommandAttachments();
            };
            reader.readAsDataURL(file);
        }
        
        function renderCommandAttachments() {
            const preview = document.getElementById('commandPastePreview');
            if (commandAttachments.length === 0) {
                preview.classList.remove('active');
                preview.innerHTML = '';
                return;
            }
            
            preview.classList.add('active');
            preview.innerHTML = commandAttachments.map((att, idx) => {
                if (att.type.startsWith('image/')) {
                    return `
                        <div class="command-attachment-item" style="position: relative; display: inline-block; margin-right: 0.5rem;">
                            <img src="${att.data}" alt="${att.filename}">
                            <button class="remove-btn" onclick="removeCommandAttachment(${idx})" title="Remove"></button>
                        </div>
                    `;
                } else {
                    return `
                        <div class="command-attachment-item" style="display: inline-flex; align-items: center; gap: 0.25rem; background: var(--bg-dark); padding: 0.25rem 0.5rem; border-radius: 4px; margin-right: 0.5rem;">
                            <span class="command-file-name">${att.filename}</span>
                            <button class="remove-btn" onclick="removeCommandAttachment(${idx})" title="Remove" style="position: static; width: 16px; height: 16px; font-size: 10px; line-height: 12px;"></button>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function removeCommandAttachment(idx) {
            commandAttachments.splice(idx, 1);
            renderCommandAttachments();
        }
        
        function clearCommandAttachments() {
            commandAttachments = [];
            renderCommandAttachments();
        }
        
        // Send message to Jarvis via backend
        let pendingMessageId = null; // Track message we're waiting on to avoid WS duplicates
        
        async function sendJarvisMessage() {
            const input = document.getElementById('jarvisChatInput');
            let message = input.value.trim();
            if (!message && commandAttachments.length === 0) return;
            if (jarvisLoading) return;
            
            // If replying to a message, prepend the quote
            if (commandBarReplyingTo) {
                message = `> ** Reply to ${commandBarReplyingTo.name}:** ${commandBarReplyingTo.preview}\n\n${message}`;
                clearCommandBarReply();
            }
            
            // Prepare attachments for sending
            const attachmentsToSend = commandAttachments.length > 0 ? [...commandAttachments] : null;
            
            // Clear input immediately and reset height
            input.value = '';
            input.style.height = 'auto';
            clearCommandAttachments();
            
            // Optimistic UI: add user message immediately
            const optimisticMsg = {
                id: null, // Will be assigned by server
                role: 'user',
                content: message || '(see attachment)',
                attachments: attachmentsToSend,
                time: formatTimeNow(),
                _optimistic: true // Mark as optimistic for later replacement
            };
            jarvisChatHistory.push(optimisticMsg);
            jarvisHistoryBySession[currentSessionKey] = jarvisChatHistory;
            renderJarvisChat();
            
            // Show typing indicator (both expanded and collapsed)
            jarvisLoading = true;
            document.getElementById('jarvisThinking').style.display = 'inline';
            document.getElementById('jarvisThinkingCollapsed').style.display = 'inline-flex';
            document.getElementById('jarvisSendBtn').disabled = true;
            
            try {
                const payload = { 
                    message: message || '(see attachment)',
                    session: currentSessionKey
                };
                if (attachmentsToSend) {
                    payload.attachments = attachmentsToSend;
                }
                
                // Retry logic for transient failures (e.g., container restart)
                let res, data;
                const maxRetries = 3;
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        res = await fetch('/api/jarvis/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        data = await res.json();
                        break; // Success, exit retry loop
                    } catch (fetchErr) {
                        if (attempt < maxRetries) {
                            console.log(`Jarvis fetch attempt ${attempt} failed, retrying in ${attempt}s...`);
                            await new Promise(r => setTimeout(r, attempt * 1000));
                        } else {
                            throw fetchErr; // Final attempt failed
                        }
                    }
                }
                
                // Reload history from server to get the new messages with proper IDs
                // This will replace the optimistic message with the real one
                await loadJarvisHistory(currentSessionKey);
                
                if (data.response) {
                    lastJarvisMessage = data.response.length > 60 
                        ? data.response.substring(0, 60) + '...' 
                        : data.response;
                    updateCommandBarPreview();
                } else if (data.error) {
                    // Show error inline
                    jarvisChatHistory.push({ role: 'assistant', content: `Error: ${data.error}`, time: formatTimeNow() });
                    renderJarvisChat();
                }
            } catch (e) {
                console.error('Jarvis chat error:', e);
                // If we're reconnecting, show a gentler message
                if (wsReconnecting || !wsConnected) {
                    jarvisChatHistory.push({ 
                        role: 'assistant', 
                        content: ' Connection interrupted. Your message will be sent when reconnected. Please wait...', 
                        time: formatTimeNow(),
                        _pending: true
                    });
                } else {
                    jarvisChatHistory.push({ role: 'assistant', content: 'Failed to reach Jarvis. Is OpenClaw running?', time: formatTimeNow() });
                }
                renderJarvisChat();
            } finally {
                jarvisLoading = false;
                document.getElementById('jarvisThinking').style.display = 'none';
                document.getElementById('jarvisThinkingCollapsed').style.display = 'none';
                document.getElementById('jarvisSendBtn').disabled = false;
            }
        }
        
        // Render chat messages
        let commandBarReplyingTo = null;
        let commandBarExportMode = false;
        
        function renderJarvisChat() {
            const container = document.getElementById('jarvisChatMessages');
            const b = window.BRANDING || {};
            const mainAgentName = b.mainAgentName || 'Assistant';
            const mainAgentEmoji = b.mainAgentEmoji || '';
            
            if (jarvisChatHistory.length === 0) {
                container.innerHTML = `<div style="text-align: center; color: var(--text-muted); padding: 2rem;">Chat with ${mainAgentName} directly from the task board.</div>`;
            } else {
                container.innerHTML = jarvisChatHistory.map((msg, idx) => {
                    const isUser = msg.role === 'user';
                    const icon = isUser ? '' : mainAgentEmoji;
                    const name = isUser ? 'You' : mainAgentName;
                    
                    // Render attachments if present
                    let attachmentsHtml = '';
                    if (msg.attachments && msg.attachments.length > 0) {
                        attachmentsHtml = '<div style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">' +
                            msg.attachments.map(att => {
                                if (att.type && att.type.startsWith('image/')) {
                                    return `<img src="${att.data}" alt="${att.filename || 'image'}" style="max-width: 200px; max-height: 150px; border-radius: 6px; cursor: pointer;" onclick="openImageViewer('${att.data}')">`;
                                } else {
                                    return `<div style="padding: 0.25rem 0.5rem; background: var(--bg-dark); border-radius: 4px; font-size: 0.8rem;">${escapeHtml(att.filename || 'file')}</div>`;
                                }
                            }).join('') + '</div>';
                    }
                    
                    const preview = (msg.content || '').substring(0, 80).replace(/'/g, "\\'");
                    
                    return `
                    <div class="jarvis-message ${msg.role}" data-msg-idx="${idx}">
                        <div class="command-export-checkbox-col">
                            <input type="checkbox" class="command-export-checkbox" data-msg-idx="${idx}">
                        </div>
                        <div class="jarvis-message-body">
                            <div class="msg-header">
                                <span>${icon} ${name}${msg.time ? '  -  ' + msg.time : ''}</span>
                                <span class="msg-actions" style="margin-left:auto;">
                                    <button class="msg-action-btn cmd-reply-btn" data-name="${name}" data-idx="${idx}" title="Reply"></button>
                                    <button class="msg-action-btn cmd-copy-btn" data-idx="${idx}" title="Copy"></button>
                                    <button class="msg-action-btn cmd-delete-btn" data-idx="${idx}" title="Delete" style="color: var(--danger, #dc3545);"></button>
                                </span>
                            </div>
                            <div class="msg-content">${formatMessageContent(msg.content || '')}${attachmentsHtml}</div>
                        </div>
                    </div>
                `}).join('');
            }
            container.scrollTop = container.scrollHeight;
        }
        
        function replyToCommandBarMessage(name, preview) {
            commandBarReplyingTo = { name, preview };
            
            const inputArea = document.querySelector('.jarvis-chat-input-area');
            if (!inputArea) {
                console.warn('jarvis-chat-input-area not found');
                return;
            }
            let replyPreview = inputArea.querySelector('.reply-preview');
            if (!replyPreview) {
                replyPreview = document.createElement('div');
                replyPreview.className = 'reply-preview';
                inputArea.insertBefore(replyPreview, inputArea.firstChild);
            }
            replyPreview.innerHTML = `
                <span class="reply-preview-text"> Replying to <strong>${name}</strong>: ${preview}</span>
                <button class="reply-preview-close" onclick="clearCommandBarReply()"></button>
            `;
            document.getElementById('jarvisChatInput')?.focus();
        }
        
        function clearCommandBarReply() {
            commandBarReplyingTo = null;
            const replyPreview = document.querySelector('.jarvis-chat-input-area .reply-preview');
            if (replyPreview) replyPreview.remove();
        }
        
        // Event delegation for command bar chat buttons (handles special chars in content)
        document.addEventListener('click', function(e) {
            const msgEl = e.target.closest('.jarvis-message');
            if (!msgEl || !msgEl.closest('#jarvisChatMessages')) return;
            
            const idx = parseInt(msgEl.dataset.msgIdx);
            
            // Reply button
            if (e.target.closest('.cmd-reply-btn')) {
                e.preventDefault();
                e.stopPropagation();
                const btn = e.target.closest('.cmd-reply-btn');
                const name = btn.dataset.name;
                const content = jarvisChatHistory[idx]?.content || '';
                const preview = content.substring(0, 80);
                replyToCommandBarMessage(name, preview + '...');
                return;
            }
            
            // Copy button
            if (e.target.closest('.cmd-copy-btn')) {
                e.preventDefault();
                e.stopPropagation();
                copyCommandBarMessage(idx);
                return;
            }
            
            // Delete button
            if (e.target.closest('.cmd-delete-btn')) {
                e.preventDefault();
                e.stopPropagation();
                deleteCommandBarMessage(idx);
                return;
            }
        });
        
        function copyCommandBarMessage(idx) {
            const content = jarvisChatHistory[idx]?.content || '';
            if (!content) {
                console.warn('No content to copy');
                return;
            }
            
            const btn = document.querySelector(`.jarvis-message[data-msg-idx="${idx}"] .msg-action-btn[title="Copy"]`);
            
            // Modern clipboard API with fallback
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(content).then(() => {
                    showCopyFeedback(btn);
                }).catch(err => {
                    console.error('Clipboard write failed:', err);
                    fallbackCopy(content, btn);
                });
            } else {
                fallbackCopy(content, btn);
            }
        }
        
        function deleteCommandBarMessage(idx) {
            if (!confirm('Delete this message? This cannot be undone.')) return;
            
            // Remove from history array
            jarvisChatHistory.splice(idx, 1);
            
            // Also remove from session-specific history if exists
            if (currentSessionKey && jarvisHistoryBySession[currentSessionKey]) {
                jarvisHistoryBySession[currentSessionKey] = [...jarvisChatHistory];
            }
            
            // Re-render the chat
            renderJarvisChat();
        }
        
        function toggleCommandBarExportMode() {
            commandBarExportMode = !commandBarExportMode;
            const container = document.getElementById('jarvisChatMessages');
            
            if (commandBarExportMode) {
                container.classList.add('export-mode');
                let controls = document.getElementById('commandExportControls');
                if (!controls) {
                    controls = document.createElement('div');
                    controls.id = 'commandExportControls';
                    controls.style.cssText = 'display:flex;gap:0.5rem;padding:0.5rem;background:var(--bg-column);border-bottom:1px solid var(--border);';
                    controls.innerHTML = `
                        <button class="btn btn-secondary" onclick="selectAllCommandBarMessages(true)">All</button>
                        <button class="btn btn-secondary" onclick="selectAllCommandBarMessages(false)">None</button>
                        <button class="btn" onclick="exportCommandBarMessages()">Download</button>
                        <button class="btn btn-secondary" onclick="toggleCommandBarExportMode()">Cancel</button>
                    `;
                    container.parentElement.insertBefore(controls, container);
                }
            } else {
                container.classList.remove('export-mode');
                const controls = document.getElementById('commandExportControls');
                if (controls) controls.remove();
                document.querySelectorAll('.command-export-checkbox').forEach(cb => cb.checked = false);
            }
        }
        
        function selectAllCommandBarMessages(select) {
            document.querySelectorAll('.command-export-checkbox').forEach(cb => cb.checked = select);
        }
        
        function exportCommandBarMessages() {
            const selected = Array.from(document.querySelectorAll('.command-export-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.msgIdx));
            
            if (selected.length === 0) {
                alert('Select at least one message.');
                return;
            }
            
            const b = window.BRANDING || {};
            const mainAgentName = b.mainAgentName || 'Assistant';
            
            let md = `# Command Bar Chat Export\n\n**Exported:** ${new Date().toLocaleString()}\n\n---\n\n`;
            selected.forEach(idx => {
                const msg = jarvisChatHistory[idx];
                if (msg) {
                    const name = msg.role === 'user' ? 'You' : mainAgentName;
                    md += `### ${name}  ${msg.time || ''}\n\n${msg.content}\n\n---\n\n`;
                }
            });
            
            const blob = new Blob([md], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `command-bar-export-${Date.now()}.md`;
            a.click();
            URL.revokeObjectURL(url);
            
            toggleCommandBarExportMode();
        }
        
        // Handle incoming messages from WebSocket (for proactive Jarvis messages)
        function handleJarvisWebSocketMessage(msg) {
            if (msg.content) {
                const msgSession = msg.session_key || 'main';
                
                // If we're actively sending a message to this session, skip WS updates
                // The REST response + loadJarvisHistory will handle it authoritatively
                if (jarvisLoading && msgSession === currentSessionKey) {
                    console.log('Skipping WS message during active send:', msg.id);
                    return;
                }
                
                // Initialize session history if needed
                if (!jarvisHistoryBySession[msgSession]) {
                    jarvisHistoryBySession[msgSession] = [];
                }
                
                // Check for duplicates by ID or content (also check optimistic messages)
                const sessionHistory = jarvisHistoryBySession[msgSession];
                const isDupe = sessionHistory.some(h => 
                    (msg.id && h.id === msg.id) || 
                    (h._optimistic && h.role === msg.role && h.content === msg.content) ||
                    (h.role === msg.role && h.content === msg.content && h.time === formatTime(msg.timestamp))
                );
                
                if (!isDupe) {
                    const newMsg = { 
                        id: msg.id,
                        session_key: msgSession,
                        role: msg.role, 
                        content: msg.content, 
                        attachments: msg.attachments,
                        time: msg.timestamp ? formatTime(msg.timestamp) : formatTimeNow() 
                    };
                    
                    // Add to session-specific history
                    jarvisHistoryBySession[msgSession].push(newMsg);
                    
                    // If this is the current session, update display
                    if (msgSession === currentSessionKey) {
                        jarvisChatHistory.push(newMsg);
                        if (msg.role === 'assistant') {
                            lastJarvisMessage = msg.content.length > 60 ? msg.content.substring(0, 60) + '...' : msg.content;
                            updateCommandBarPreview();
                        }
                        renderJarvisChat();
                    }
                }
            }
        }
        
        async function expandCommandBar() {
            if (commandBarExpanded) return;
            commandBarExpanded = true;
            document.getElementById('commandBar').classList.add('expanded');
            document.getElementById('commandBarOverlay').classList.add('active');
            document.querySelector('.header').classList.add('command-active');
            
            // Ensure paste handler is attached
            setupCommandPasteHandler();
            
            document.getElementById('jarvisChatInput').focus();
            
            // Load sessions and history
            await loadSessions();
            updateDeleteButtonVisibility(); // Enable/disable edit/delete buttons based on current session
            
            if (!jarvisHistoryBySession[currentSessionKey] || jarvisHistoryBySession[currentSessionKey].length === 0) {
                await loadJarvisHistory(currentSessionKey);
            } else {
                jarvisChatHistory = jarvisHistoryBySession[currentSessionKey];
            }
            renderJarvisChat();
        }
        
        function collapseCommandBar() {
            commandBarExpanded = false;
            commandFullsize = false;
            document.getElementById('commandBar').classList.remove('expanded');
            document.getElementById('commandBarExpanded').classList.remove('fullsize');
            document.getElementById('commandBarOverlay').classList.remove('active');
            document.querySelector('.header').classList.remove('command-active');
            clearCommandAttachments();
            updateCommandBarPreview();
        }
        
        function toggleCommandFullsize() {
            commandFullsize = !commandFullsize;
            const panel = document.getElementById('commandBarExpanded');
            const btn = document.getElementById('commandExpandBtn');
            
            // SVG icons for fullscreen (corners out) and exit fullscreen (corners in)
            const expandIcon = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><polyline points="21 3 14 10"/><polyline points="3 21 10 14"/></svg>';
            const shrinkIcon = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>';
            
            if (commandFullsize) {
                panel.classList.add('fullsize');
                btn.innerHTML = shrinkIcon;
                btn.title = 'Exit Fullscreen';
            } else {
                panel.classList.remove('fullsize');
                btn.innerHTML = expandIcon;
                btn.title = 'Fullscreen';
            }
        }
        
        function updateCommandBarPreview() {
            document.getElementById('commandBarPreview').textContent = lastJarvisMessage;
        }
        
        // Escape key closes command bar
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && commandBarExpanded) {
                collapseCommandBar();
            }
        });
        
        // Help Modal
        function openHelpModal() {
            const b = config.branding || {};
            const mainAgent = b.mainAgentName || 'Assistant';
            const mainEmoji = b.mainAgentEmoji || '';
            
            document.getElementById('helpContent').innerHTML = `
                <section class="help-section">
                    <h3> Overview</h3>
                    <p>The DEV Task Board is a multi-agent project management system. Tasks flow through stages while AI agents collaborate to complete work under human supervision.</p>
                </section>
                
                <section class="help-section">
                    <h3> Workflow Stages</h3>
                    <div class="help-flow">
                        <span class="flow-stage">Backlog</span>  
                        <span class="flow-stage">In Progress</span>  
                        <span class="flow-stage">Review</span>  
                        <span class="flow-stage">Done</span>
                    </div>
                    <p class="flow-note"> <strong>Blocked</strong> can branch from In Progress when waiting on info</p>
                    <ul>
                        <li><strong>Backlog:</strong> Tasks waiting to be started</li>
                        <li><strong>In Progress:</strong> Agent actively working (auto-spawns AI session)</li>
                        <li><strong>Review:</strong> Work complete, awaiting User approval</li>
                        <li><strong>Done:</strong> Only User can move tasks here (final approval)</li>
                        <li><strong>Blocked:</strong> Waiting on external input or decision</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Agents</h3>
                    <div class="agent-list">
                        <div class="agent-item">${mainEmoji} <strong>${mainAgent}</strong>  Main coordinator, handles command bar chat</div>
                        <div class="agent-item"> <strong>Architect</strong>  System design, patterns, scalability</div>
                        <div class="agent-item"> <strong>Security Auditor</strong>  SOC2, HIPAA, CIS compliance</div>
                        <div class="agent-item"> <strong>Code Reviewer</strong>  Code quality, best practices</div>
                        <div class="agent-item"> <strong>UX Manager</strong>  User flows, UI consistency</div>
                        <div class="agent-item"> <strong>User</strong>  Human supervisor (you!)</div>
                    </div>
                </section>
                
                <section class="help-section">
                    <h3> Auto-Spawn: How Agents Activate</h3>
                    <ol>
                        <li>Assign a task to an agent (e.g., Architect)</li>
                        <li>Drag the card to <strong>In Progress</strong></li>
                        <li>The agent's AI session spawns automatically</li>
                        <li>Agent posts updates as comments on the card</li>
                        <li>Agent moves to Review when done</li>
                        <li>You review and move to Done (or request changes)</li>
                    </ol>
                </section>
                
                <section class="help-section">
                    <h3> Task Conversations</h3>
                    <p>Each task card has a built-in chat section:</p>
                    <ul>
                        <li>Click any card to open the task modal with conversation</li>
                        <li>Use <strong>Theater Mode</strong> () to expand for focused work</li>
                        <li>Conversation auto-scrolls with messages capped to viewport</li>
                        <li>Attach images and files directly to messages</li>
                        <li>Use <strong>@mention</strong> to tag other agents into the conversation</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Session Persistence</h3>
                    <p>Each agent maintains a <strong>persistent session</strong> per task:</p>
                    <ul>
                        <li>Sessions stay alive while task is In Progress or Review</li>
                        <li>Back-and-forth conversations preserve full context</li>
                        <li>No cold starts  agents remember previous messages</li>
                        <li>Sessions terminate when task moves to Done</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Action Items</h3>
                    <p>Cards can have action items (shown as notification badges):</p>
                    <ul>
                        <li><span style="color: #f59e0b;"> Question</span>  Agent needs clarification</li>
                        <li><span style="color: #10b981;"> Completion</span>  Auto-created when moved to Review</li>
                        <li><span style="color: #ef4444;"> Blocker</span>  Auto-created when moved to Blocked</li>
                    </ul>
                    <p><strong>Managing action items:</strong></p>
                    <ul>
                        <li>Click the <strong>checkbox</strong> to mark an item as resolved</li>
                        <li>Click <strong></strong> to delete an item permanently</li>
                        <li>Archive resolved items to hide them from view</li>
                        <li>Click <strong> Archive</strong> to review archived items</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Command Bar</h3>
                    <p>Click the search bar in the header to chat directly with ${mainAgent}:</p>
                    <ul>
                        <li>Ask questions about the project</li>
                        <li>Give high-level instructions</li>
                        <li>Paste images or files (Ctrl+V)</li>
                        <li>Create new sessions with <strong>+ New</strong></li>
                        <li>Click  to expand to full size</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Visual Indicators</h3>
                    <ul>
                        <li><strong>Glowing card</strong>  AI agent actively working (consuming tokens)</li>
                        <li><strong>Red badge</strong>  Open action items needing attention</li>
                        <li><strong>Agent colors</strong>  Each agent has a distinct color tag</li>
                        <li><strong>Priority colors</strong>  Critical (red), High (orange), Medium (yellow), Low (green)</li>
                        <li><strong>Save feedback</strong>  Checkmark spins then glows green on save</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Security</h3>
                    <ul>
                        <li>All agent sessions run with guardrails (filesystem boundaries, forbidden actions)</li>
                        <li>Agents cannot access paths outside authorized directories</li>
                        <li>External API calls require approval via action items</li>
                        <li>Only User can finalize tasks (move to Done)</li>
                        <li>Delete confirmation required for destructive actions</li>
                    </ul>
                </section>
                
                <section class="help-section">
                    <h3> Keyboard Shortcuts</h3>
                    <ul>
                        <li><strong>Shift+Enter</strong>  New line in chat input</li>
                        <li><strong>Enter</strong>  Send message</li>
                        <li><strong>Ctrl+V</strong>  Paste image from clipboard</li>
                        <li><strong>Escape</strong>  Close modals and dialogs</li>
                    </ul>
                </section>
            `;
            
            document.getElementById('helpModal').classList.add('active');
        }
        
        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
        }
        
        // Mention/Tag Agents (main agent added dynamically from config)
        window.AGENT_ICONS_MAP = {
            'Architect': '',
            'Security Auditor': '',
            'Code Reviewer': '',
            'UX Manager': ''
        };
        
        function toggleMentionDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('mentionDropdown');
            const isActive = dropdown.classList.contains('active');
            
            if (isActive) {
                dropdown.classList.remove('active');
            } else {
                // Populate with agents (excluding User and Unassigned)
                const agents = config.agents.filter(a => a !== 'User' && a !== 'Unassigned');
                dropdown.innerHTML = agents.map(agent => `
                    <div class="mention-option" onclick="insertMention('${agent}')">
                        <span>${AGENT_ICONS_MAP[agent] || ''}</span>
                        <span>${agent}</span>
                    </div>
                `).join('');
                dropdown.classList.add('active');
            }
        }
        
        function insertMention(agent) {
            const input = document.getElementById('chatInput');
            const mention = `@${agent} `;
            
            // Insert at cursor position or append
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            
            input.value = text.substring(0, start) + mention + text.substring(end);
            input.focus();
            input.setSelectionRange(start + mention.length, start + mention.length);
            
            document.getElementById('mentionDropdown').classList.remove('active');
        }
        
        // Close mention dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.mention-btn') && !e.target.closest('.mention-dropdown')) {
                document.getElementById('mentionDropdown')?.classList.remove('active');
            }
        });
        
        // Start
        init();
        connectWebSocket();
    </script>
</body>
</html>
